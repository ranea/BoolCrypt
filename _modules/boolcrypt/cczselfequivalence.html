<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>boolcrypt.cczselfequivalence &mdash; BoolCrypt 0.1.dev documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> BoolCrypt
          </a>
              <div class="version">
                0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">BoolCrypt 0.1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../boolcrypt.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BoolCrypt</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>boolcrypt.cczselfequivalence</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for boolcrypt.cczselfequivalence</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Find self-equivalences of a function by finding the self-equivalences</span>
<span class="sd">of its graph (i.e., also called graph automorphisms)</span>
<span class="sd">parametrized by a CCZ-equivalent function with lower degree.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">boolcrypt.utilities</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">matrix2anf</span><span class="p">,</span> <span class="n">get_ct_coeff</span><span class="p">,</span> <span class="n">get_smart_print</span><span class="p">,</span> <span class="n">get_anf_coeffmatrix_str</span><span class="p">,</span>
    <span class="n">substitute_anf</span><span class="p">,</span> <span class="n">get_time</span><span class="p">,</span> <span class="n">anf2matrix</span><span class="p">,</span> <span class="n">get_all_symbolic_coeff</span><span class="p">,</span> <span class="n">get_symbolic_anf</span><span class="p">,</span>
    <span class="n">vector2int</span><span class="p">,</span> <span class="n">int2vector</span><span class="p">,</span> <span class="n">anf2lut</span><span class="p">,</span> <span class="n">is_invertible</span><span class="p">,</span> <span class="n">compose_anf_fast</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">boolcrypt.equivalence</span> <span class="kn">import</span> <span class="n">check_ccz_equivalence_anf</span>

<span class="kn">from</span> <span class="nn">boolcrypt.functionalequations</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_sp</span><span class="p">,</span> <span class="n">find_fixed_vars</span><span class="p">,</span> <span class="n">solve_functional_equation</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">sage.all</span>

<span class="kn">from</span> <span class="nn">sage.rings.polynomial.pbori.pbori</span> <span class="kn">import</span> <span class="n">BooleanPolynomialVector</span>
<span class="kn">from</span> <span class="nn">sage.sat.boolean_polynomials</span> <span class="kn">import</span> <span class="n">solve</span> <span class="k">as</span> <span class="n">solve_sat</span>

<span class="n">GF</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">GF</span>
<span class="n">PolynomialRing</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">PolynomialRing</span>
<span class="n">BooleanPolynomialRing</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">BooleanPolynomialRing</span>


<div class="viewcode-block" id="find_self_equivalence"><a class="viewcode-back" href="../../boolcrypt.cczselfequivalence.html#boolcrypt.cczselfequivalence.find_self_equivalence">[docs]</a><span class="k">def</span> <span class="nf">find_self_equivalence</span><span class="p">(</span>
    <span class="c1"># main args</span>
    <span class="n">ccz_anf</span><span class="p">,</span> <span class="n">admissible_mapping</span><span class="p">,</span>
    <span class="c1"># alternative modes</span>
    <span class="n">ccz_anf_implicit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="c1"># degree args</span>
    <span class="n">right_se_degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">inv_left_se_degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">se_ct_terms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># optimization constraints</span>
    <span class="n">ignore_diagonal_equations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">add_invertibility_equations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_determinant_equation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">check_se</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">bpr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1"># optional input args</span>
    <span class="n">ccz_se_anf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">prefix_se_coeffs</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">,</span>
    <span class="n">input_ccz_anf_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">anf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_anf_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_input_anf_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1"># optional output args</span>
    <span class="n">return_ccz_se</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="c1"># printing args</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1"># extra args passed to solve_functional_equation()</span>
    <span class="o">**</span><span class="n">solve_args</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find a SE of F by finding a SE of the graph of G.</span>

<span class="sd">    Let F be the function (optionally) given by ``anf`` and</span>
<span class="sd">    G its CCZ-equivalent function through the ``admissible_mapping`` L,</span>
<span class="sd">    that is, Graph(F)=L(Graph(G)).</span>
<span class="sd">    F (if given) and G must be in ANF form, but L can be given in ANF,</span>
<span class="sd">    as a matrix, or as a (matrix, vector) pair.</span>
<span class="sd">    If F is not given, its number of input variables must be</span>
<span class="sd">    given in ``num_input_anf_vars``.</span>

<span class="sd">    Graph(F) is defined as usual, {(x, y): for all x, y=F(x)}.</span>
<span class="sd">    If ccz_anf_implicit=False, Graph(G) is defined similarly as Graph(F):</span>
<span class="sd">    Otherwise, Graph(G)={(x, y): G(x, y)=0} if ccz_anf_implicit=True.</span>

<span class="sd">    This methods finds a self-equivalence (SE) (A, B) with given degrees of F</span>
<span class="sd">    (a pair of permutations (A,B) such that B F A = F) by finding</span>
<span class="sd">    a SE (an automorphism) of the graph of F parametrized by G.</span>
<span class="sd">    A is also called a right SE and B a left SE.</span>
<span class="sd">    If no solution is found, None is returned.</span>

<span class="sd">    If the SE degrees are both 1 and se_ct_terms=True</span>
<span class="sd">    (resp. False), this method finds an affine (resp. linear) SE.</span>

<span class="sd">    This methods returns SE (A, B) by finding a Graph(G)-SE C=(c_0, c_1)</span>
<span class="sd">    s.t. L C L^{-1} is diagonal and can be written as L C L^{-1} = (A, B^(-1)).</span>
<span class="sd">    This is done by solving the functional eq.</span>
<span class="sd">    G(c_0(u, G(u))) = c_1(u, G(u))) if ccz_anf_implicit=False,</span>
<span class="sd">    or D G C = C (D invertible, D(0)=0) if ccz_anf_implicit=True.</span>
<span class="sd">    When ccz_anf_implicit=True, this method is not complete, meaning that</span>
<span class="sd">    not all the Graph(G)-SE can be found from the equation G C = C.</span>

<span class="sd">    The ANF of C can be optionally given in ccz_se_anf to speed up this method.</span>
<span class="sd">    Otherwise, it will be created using get_symbolic_anf.</span>

<span class="sd">    If return_ccz_se=False, the SE of F are returned. However,</span>
<span class="sd">    the left SE B are not given in the output, but their inverses B^(-1).</span>
<span class="sd">    If return_ccz_se=True, instead of returning the SE (A, B),</span>
<span class="sd">    the Graph(G)-self-equivalences C are returned instead.</span>

<span class="sd">    If check_se=True, checks that the found SE (A, B) are indeed SE of F.</span>

<span class="sd">    If add_invertibility_equations=True, the equations that</span>
<span class="sd">    impose (A, B) to be invertible are added to the system of equations.</span>
<span class="sd">    In this case and if right_se_degree=1, the constraint ``det(A)=1``</span>
<span class="sd">    is added, otherwise (if inv_left_se_degree=1), the constraint</span>
<span class="sd">    ``det(B^(-1))=1``.</span>
<span class="sd">    If add_invertibility_equations=True and ignore_determinant_equation=False,</span>
<span class="sd">    then the high-degree equation involving the determinant is not added</span>
<span class="sd">    (and only some necessary but not sufficient constraints from</span>
<span class="sd">    ``_get_lowdeg_inv_equations`` are added).</span>

<span class="sd">    input_ccz_anf_vars and input_anf_vars are two lists with the inputs vars</span>
<span class="sd">    (containing Boolean variables or strings) of the given G and F</span>
<span class="sd">    (not needed for non-symbolic anfs).</span>

<span class="sd">    A Boolean polynomial ring bpr can be given to determine the</span>
<span class="sd">    term order. Otherwise, lexicographic order will be used</span>
<span class="sd">    (x0 &gt; x1 &gt; ..., F0 &gt; F1 &gt; ... &gt; G0 &gt; G1 &gt; ... ).</span>

<span class="sd">    If ignore_diagonal_equations is True, the constraints that ensured</span>
<span class="sd">    that L C L^{-1} is diagonal and with proper degrees are ignored.</span>
<span class="sd">    In this case, add_invertibility_equations must be False.</span>

<span class="sd">    Named arguments from ``**solve_args`` are passed to solve_functional_equation().</span>
<span class="sd">    In particular, if return_mode and num_sat_solutions are not given,</span>
<span class="sd">    only one solution is found and the ANF of A and B^(-1) are given.</span>

<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import lut2anf, get_lut_inversion, anf2lut, invert_lut</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.equivalence import check_self_le_lut</span>
<span class="sd">        &gt;&gt;&gt; f = lut2anf(get_lut_inversion(4))</span>
<span class="sd">        &gt;&gt;&gt; g = lut2anf([0, 15, 9, 7, 4, 14, 1, 3, 10, 6, 13, 2, 8, 5, 11, 12])</span>
<span class="sd">        &gt;&gt;&gt; am = [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,</span>
<span class="sd">        ... 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1,</span>
<span class="sd">        ... 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1]</span>
<span class="sd">        &gt;&gt;&gt; am = sage.all.matrix(GF(2), 4*2, 4*2, am)</span>
<span class="sd">        &gt;&gt;&gt; a, b_inv = find_self_equivalence(g, am, anf=f, se_ct_terms=False,</span>
<span class="sd">        ...     only_linear_fixed_vars=True, verbose=True)  # doctest:+ELLIPSIS,+NORMALIZE_WHITESPACE</span>
<span class="sd">        finding SE (A, B) of F through the graph of G with deg(A), deg(B^(-1)) degrees (1, 1)</span>
<span class="sd">        - F:</span>
<span class="sd">        [x0*x1*x2 x0*x1*x3 x0*x2*x3 x1*x2*x3|   x0*x1    x0*x2    x0*x3    x1*x2    x1*x3    x2*x3|      x0       x1       x2       x3]</span>
<span class="sd">        [-----------------------------------+-----------------------------------------------------+-----------------------------------]</span>
<span class="sd">        [       1        0        0        1|       0        1        0        1        0        0|       1        1        1        1]</span>
<span class="sd">        [       0        1        0        0|       1        1        0        1        1        0|       0        0        0        1]</span>
<span class="sd">        [       0        0        1        0|       1        1        1        0        0        0|       0        0        1        1]</span>
<span class="sd">        [       0        0        0        1|       0        0        1        0        1        1|       0        1        1        1]</span>
<span class="sd">        - G (CCZ-equivalent of F):</span>
<span class="sd">        [x0*x1*x2 x0*x1*x3 x0*x2*x3 x1*x2*x3|   x0*x1    x0*x2    x0*x3    x1*x2    x1*x3    x2*x3|      x0       x1       x2       x3]</span>
<span class="sd">        [-----------------------------------+-----------------------------------------------------+-----------------------------------]</span>
<span class="sd">        [       1        0        0        0|       1        1        1        0        0        0|       1        1        0        0]</span>
<span class="sd">        [       0        1        0        0|       0        0        1        0        1        1|       1        0        0        1]</span>
<span class="sd">        [       0        0        1        0|       0        1        0        1        1        1|       1        0        1        0]</span>
<span class="sd">        [       1        0        0        1|       0        0        0        1        1        0|       1        1        0        1]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | computing C</span>
<span class="sd">        - C (self-equivalence of Graph(G)):</span>
<span class="sd">        [   x0    x1    x2    x3    x4    x5    x6    x7]</span>
<span class="sd">        [-----------------------------------------------]</span>
<span class="sd">        [ca0_0 ca0_1 ca0_2 ca0_3 ca0_4 ca0_5 ca0_6 ca0_7]</span>
<span class="sd">        [ca1_0 ca1_1 ca1_2 ca1_3 ca1_4 ca1_5 ca1_6 ca1_7]</span>
<span class="sd">        [ca2_0 ca2_1 ca2_2 ca2_3 ca2_4 ca2_5 ca2_6 ca2_7]</span>
<span class="sd">        [ca3_0 ca3_1 ca3_2 ca3_3 ca3_4 ca3_5 ca3_6 ca3_7]</span>
<span class="sd">        [cb0_0 cb0_1 cb0_2 cb0_3 cb0_4 cb0_5 cb0_6 cb0_7]</span>
<span class="sd">        [cb1_0 cb1_1 cb1_2 cb1_3 cb1_4 cb1_5 cb1_6 cb1_7]</span>
<span class="sd">        [cb2_0 cb2_1 cb2_2 cb2_3 cb2_4 cb2_5 cb2_6 cb2_7]</span>
<span class="sd">        [cb3_0 cb3_1 cb3_2 cb3_3 cb3_4 cb3_5 cb3_6 cb3_7]</span>
<span class="sd">        number of C input variables: 8</span>
<span class="sd">        number of symbolic coefficients: 64</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | getting equations from L C L^(-1) = diagonal</span>
<span class="sd">        - L C L^(-1) (L admissible mapping L(Graph(G)=Graph(F)):</span>
<span class="sd">        [...]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | finding fixed variables and reducing initial and diagonal equations</span>
<span class="sd">        reducing 32 equations with mode gauss and degrees (d,#) Counter({1: 32})</span>
<span class="sd">        gauss-reduction obtained 32 equations with degrees (d,#) Counter({1: 32})</span>
<span class="sd">        found 32 fixed variables, resulting in 0 equations</span>
<span class="sd">        &gt; repeating find_fixed_vars with initial reduction_mode gauss</span>
<span class="sd">        &gt; last find_fixed_vars call found 0 new fixed variables and removed 0 equations</span>
<span class="sd">        - L C L^(-1) (reduced by initial and diagonal equations):</span>
<span class="sd">        [...]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | adding invertibility equations over L C L^(-1)</span>
<span class="sd">        added 1 invertibility equations</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | solving the Graph(G)-self-equivalence functional equation</span>
<span class="sd">        ...</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | parsing and checking the Graph(G)-self-equivalence solutions</span>
<span class="sd">        Solution 1 out of 1:</span>
<span class="sd">        - L C L^(-1):</span>
<span class="sd">        [...]</span>
<span class="sd">        - SE (A, B) of F:</span>
<span class="sd">         - A:</span>
<span class="sd">        [...]</span>
<span class="sd">         - B^(-1):</span>
<span class="sd">        [...]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | returning outputs with mode=&#39;list_anfs&#39;</span>
<span class="sd">        &gt;&gt;&gt; bpr = BooleanPolynomialRing(4, &#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a = anf2lut([bpr(component) for component in a])</span>
<span class="sd">        &gt;&gt;&gt; b = invert_lut(anf2lut([bpr(component) for component in b_inv]))</span>
<span class="sd">        &gt;&gt;&gt; check_self_le_lut(get_lut_inversion(4), right_le=a, left_le=b)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; from sage.crypto.sbox import SBox</span>
<span class="sd">        &gt;&gt;&gt; f = lut2anf((0, 1, 2, 3, 4, 6, 7, 5))  # 12 LSE</span>
<span class="sd">        &gt;&gt;&gt; boolean_vars = sage.all.BooleanPolynomialRing(3*2, &#39;x&#39;).gens()</span>
<span class="sd">        &gt;&gt;&gt; iv, ov = boolean_vars[:3], boolean_vars[3:]</span>
<span class="sd">        &gt;&gt;&gt; iv, ov = list(reversed(iv)), list(reversed(ov))  # polynomials() takes x0 as MSB</span>
<span class="sd">        &gt;&gt;&gt; g = SBox((0, 1, 2, 3, 4, 6, 7, 5)).polynomials(iv, ov, groebner=True)</span>
<span class="sd">        &gt;&gt;&gt; am = sage.all.identity_matrix(GF(2), 3*2)</span>
<span class="sd">        &gt;&gt;&gt; fixed_vars = dict([(&#39;cb2_2&#39;, 0), (&#39;cb2_1&#39;, 0), (&#39;cb2_0&#39;, 0), (&#39;cb1_2&#39;, 0), (&#39;cb1_1&#39;, 0), (&#39;cb1_0&#39;, 0),</span>
<span class="sd">        ... (&#39;cb0_1&#39;, 0), (&#39;cb0_0&#39;, 0), (&#39;ca2_5&#39;, 0), (&#39;ca2_4&#39;, 0), (&#39;ca2_3&#39;, 0), (&#39;ca1_5&#39;, 0), (&#39;ca1_4&#39;, 0),</span>
<span class="sd">        ... (&#39;ca0_5&#39;, 0), (&#39;ca0_4&#39;, 0), (&#39;ca0_3&#39;, 0), (&#39;ca2_0&#39;, 0), (&#39;ca2_1&#39;, 0), (&#39;ca2_2&#39;, 1), (&#39;cb2_3&#39;, 0),</span>
<span class="sd">        ... (&#39;cb0_2&#39;, 0), (&#39;ca1_3&#39;, 0), (&#39;cb2_4&#39;, 0), (&#39;cb2_5&#39;, 1), (&#39;cd2_0&#39;, 0), (&#39;cd2_1&#39;, 0), (&#39;cd2_2&#39;, 1)])</span>
<span class="sd">        &gt;&gt;&gt; [a, b_inv], eqs, num_sols = find_self_equivalence(g, am, num_input_anf_vars=3, ccz_anf_implicit=True,</span>
<span class="sd">        ...     se_ct_terms=False, reduction_mode=None, only_linear_fixed_vars=True, return_mode=&quot;symbolic_anf&quot;,</span>
<span class="sd">        ...     num_sat_solutions=12+1, return_total_num_solutions=True,  initial_fixed_vars=fixed_vars,</span>
<span class="sd">        ...     verbose=True, debug=True)  # doctest:+ELLIPSIS,+NORMALIZE_WHITESPACE</span>
<span class="sd">        ignoring add_invertibility_equations when ccz_anf_implicit is True</span>
<span class="sd">        finding SE (A, B) of F through the graph of G with deg(A), deg(B^(-1)) degrees (1, 1)</span>
<span class="sd">        - F:</span>
<span class="sd">        []</span>
<span class="sd">        - G (CCZ-implicit-equivalent of F):</span>
<span class="sd">        [x3*x5 x4*x5|   x0    x1    x2    x3    x4    x5]</span>
<span class="sd">        [-----------+-----------------------------------]</span>
<span class="sd">        [    0     1|    1     0     0     1     0     0]</span>
<span class="sd">        [    1     1|    0     1     0     0     1     0]</span>
<span class="sd">        [    0     0|    0     0     1     0     0     1]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | computing C</span>
<span class="sd">        - C (self-equivalence of Graph(G)):</span>
<span class="sd">        [   x0    x1    x2    x3    x4    x5]</span>
<span class="sd">        [-----------------------------------]</span>
<span class="sd">        [ca0_0 ca0_1 ca0_2     0     0     0]</span>
<span class="sd">        [ca1_0 ca1_1 ca1_2     0     0     0]</span>
<span class="sd">        [    0     0     1     0     0     0]</span>
<span class="sd">        [    0     0     0 cb0_3 cb0_4 cb0_5]</span>
<span class="sd">        [    0     0     0 cb1_3 cb1_4 cb1_5]</span>
<span class="sd">        [    0     0     0     0     0     1]</span>
<span class="sd">        input variables (6): [&#39;x0&#39;, &#39;x1&#39;, &#39;x2&#39;, &#39;x3&#39;, &#39;x4&#39;, &#39;x5&#39;]</span>
<span class="sd">        symbolic coefficients (45): [&#39;ca0_0&#39;, ..., &#39;cd2_2&#39;]</span>
<span class="sd">        Boolean PolynomialRing in x0, x1, x2, x3, x4, x5, ca0_0, ..., cd2_2</span>
<span class="sd">        initial fixed vars (27):</span>
<span class="sd">            cb2_2 &lt;- 0</span>
<span class="sd">            ...</span>
<span class="sd">            cd2_2 &lt;- 1</span>
<span class="sd">        - D (from G = D G C):</span>
<span class="sd">        [   x0    x1    x2]</span>
<span class="sd">        [-----------------]</span>
<span class="sd">        [cd0_0 cd0_1 cd0_2]</span>
<span class="sd">        [cd1_0 cd1_1 cd1_2]</span>
<span class="sd">        [    0     0     1]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | getting equations from L C L^(-1) = diagonal</span>
<span class="sd">        - L C L^(-1) (L admissible mapping L(Graph(G)=Graph(F)):</span>
<span class="sd">        [   x0    x1    x2    x3    x4    x5]</span>
<span class="sd">        [-----------------------------------]</span>
<span class="sd">        [ca0_0 ca0_1 ca0_2     0     0     0]</span>
<span class="sd">        [ca1_0 ca1_1 ca1_2     0     0     0]</span>
<span class="sd">        [    0     0     1     0     0     0]</span>
<span class="sd">        [    0     0     0 cb0_3 cb0_4 cb0_5]</span>
<span class="sd">        [    0     0     0 cb1_3 cb1_4 cb1_5]</span>
<span class="sd">        [    0     0     0     0     0     1]</span>
<span class="sd">        equations from L C L^(-1) = diagonal:</span>
<span class="sd">        no equations added from L C L^(-1) = diagonal</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | finding fixed variables and reducing initial and diagonal equations</span>
<span class="sd">        - L C L^(-1) (reduced by initial and diagonal equations):</span>
<span class="sd">        [   x0    x1    x2    x3    x4    x5]</span>
<span class="sd">        [-----------------------------------]</span>
<span class="sd">        [ca0_0 ca0_1 ca0_2     0     0     0]</span>
<span class="sd">        [ca1_0 ca1_1 ca1_2     0     0     0]</span>
<span class="sd">        [    0     0     1     0     0     0]</span>
<span class="sd">        [    0     0     0 cb0_3 cb0_4 cb0_5]</span>
<span class="sd">        [    0     0     0 cb1_3 cb1_4 cb1_5]</span>
<span class="sd">        [    0     0     0     0     0     1]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | solving the Graph(G)-self-equivalence functional equation</span>
<span class="sd">        removing from initial_fixed_vars cd2_0 &lt;- 0</span>
<span class="sd">        removing from initial_fixed_vars cd2_1 &lt;- 0</span>
<span class="sd">        removing from initial_fixed_vars cd2_2 &lt;- 1</span>
<span class="sd">        ...</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | parsing and checking the Graph(G)-self-equivalence solutions</span>
<span class="sd">        finding a solution of the remaining 3 equations for checking</span>
<span class="sd">            cb0_5*cd1_1 + cb1_5*cd1_0 + cb1_5*cd1_1 + cd0_2</span>
<span class="sd">            cd1_0*cd1_1 + cd1_0 + cd1_1 + 1</span>
<span class="sd">            cb0_5*cd1_0 + cb0_5*cd1_1 + cb1_5*cd1_0 + cd1_2</span>
<span class="sd">         - solution: {cd1_2: 0, cd1_1: 0, cd1_0: 1, cd0_2: 0, cb1_5: 0, cb0_5: 0}</span>
<span class="sd">        Solution 1 out of 1:</span>
<span class="sd">        - L C L^(-1):</span>
<span class="sd">        [           x0            x1            x2            x3            x4            x5]</span>
<span class="sd">        [-----------------------------------------------------------------------------------]</span>
<span class="sd">        [        cd1_1         cd1_0 cb0_5 + cb1_5             0             0             0]</span>
<span class="sd">        [        cd1_0 cd1_0 + cd1_1         cb0_5             0             0             0]</span>
<span class="sd">        [            0             0             1             0             0             0]</span>
<span class="sd">        [            0             0             0         cd1_1         cd1_0         cb0_5]</span>
<span class="sd">        [            0             0             0         cd1_0 cd1_0 + cd1_1         cb1_5]</span>
<span class="sd">        [            0             0             0             0             0             1]</span>
<span class="sd">        - L C L^(-1) (with {cd1_2: 0, cd1_1: 0, cd1_0: 1, cd0_2: 0, cb1_5: 0, cb0_5: 0}):</span>
<span class="sd">        [x0 x1 x2 x3 x4 x5]</span>
<span class="sd">        [-----------------]</span>
<span class="sd">        [ 0  1  0  0  0  0]</span>
<span class="sd">        [ 1  1  0  0  0  0]</span>
<span class="sd">        [ 0  0  1  0  0  0]</span>
<span class="sd">        [ 0  0  0  0  1  0]</span>
<span class="sd">        [ 0  0  0  1  1  0]</span>
<span class="sd">        [ 0  0  0  0  0  1]</span>
<span class="sd">        - SE (A, B) of F:</span>
<span class="sd">         - A:</span>
<span class="sd">        [           x0            x1            x2]</span>
<span class="sd">        [-----------------------------------------]</span>
<span class="sd">        [        cd1_1         cd1_0 cb0_5 + cb1_5]</span>
<span class="sd">        [        cd1_0 cd1_0 + cd1_1         cb0_5]</span>
<span class="sd">        [            0             0             1]</span>
<span class="sd">         - B^(-1):</span>
<span class="sd">        [           x0            x1            x2]</span>
<span class="sd">        [-----------------------------------------]</span>
<span class="sd">        [        cd1_1         cd1_0         cb0_5]</span>
<span class="sd">        [        cd1_0 cd1_0 + cd1_1         cb1_5]</span>
<span class="sd">        [            0             0             1]</span>
<span class="sd">        - SE (A, B) of F (with {cd1_2: 0, cd1_1: 0, cd1_0: 1, cd0_2: 0, cb1_5: 0, cb0_5: 0}):</span>
<span class="sd">         - A:</span>
<span class="sd">        [x0 x1 x2]</span>
<span class="sd">        [--------]</span>
<span class="sd">        [ 0  1  0]</span>
<span class="sd">        [ 1  1  0]</span>
<span class="sd">        [ 0  0  1]</span>
<span class="sd">         - B^(-1):</span>
<span class="sd">        [x0 x1 x2]</span>
<span class="sd">        [--------]</span>
<span class="sd">        [ 0  1  0]</span>
<span class="sd">        [ 1  1  0]</span>
<span class="sd">        [ 0  0  1]</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        ... | returning outputs with mode=&#39;symbolic_anf&#39;</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(a, [&quot;x&quot; + str(i) for i in range(3)])</span>
<span class="sd">        [           x0            x1            x2]</span>
<span class="sd">        [-----------------------------------------]</span>
<span class="sd">        [        cd1_1         cd1_0 cb0_5 + cb1_5]</span>
<span class="sd">        [        cd1_0 cd1_0 + cd1_1         cb0_5]</span>
<span class="sd">        [            0             0             1]</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(b_inv, [&quot;x&quot; + str(i) for i in range(3)])</span>
<span class="sd">        [           x0            x1            x2]</span>
<span class="sd">        [-----------------------------------------]</span>
<span class="sd">        [        cd1_1         cd1_0         cb0_5]</span>
<span class="sd">        [        cd1_0 cd1_0 + cd1_1         cb1_5]</span>
<span class="sd">        [            0             0             1]</span>
<span class="sd">        &gt;&gt;&gt; for eq in eqs: print(eq)</span>
<span class="sd">        cb0_5*cd1_1 + cb1_5*cd1_0 + cb1_5*cd1_1 + cd0_2</span>
<span class="sd">        cd1_0*cd1_1 + cd1_0 + cd1_1 + 1</span>
<span class="sd">        cb0_5*cd1_0 + cb0_5*cd1_1 + cb1_5*cd1_0 + cd1_2</span>
<span class="sd">        &gt;&gt;&gt; num_sols</span>
<span class="sd">        12</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smart_print</span> <span class="o">=</span> <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">assert</span> <span class="n">right_se_degree</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">inv_left_se_degree</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ccz_anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">input_ccz_anf_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">ccz_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">aux_bpr</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ccz_anf</span><span class="p">)</span>
        <span class="n">input_ccz_anf_vars</span> <span class="o">=</span> <span class="n">aux_bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>

    <span class="n">missing_anf</span> <span class="o">=</span> <span class="n">anf</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">missing_anf</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_anf_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">aux_bpr</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">anf</span><span class="p">)</span>
            <span class="n">input_anf_vars</span> <span class="o">=</span> <span class="n">aux_bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">num_input_anf_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">anf_bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">num_input_anf_vars</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">input_anf_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">anf_bpr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_input_anf_vars</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
            <span class="n">anf</span> <span class="o">=</span> <span class="p">[</span><span class="n">anf_bpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ccz_anf</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">anf</span> <span class="o">=</span> <span class="p">[</span><span class="n">anf_bpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_ccz_anf_vars</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_input_anf_vars</span><span class="p">)]</span>

    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_se_coeffs</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_ccz_anf_vars</span><span class="p">))</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_se_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccz_anf</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_ccz_anf_vars</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_ccz_anf_vars</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_invertibility_equations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s1">&#39;ignoring add_invertibility_equations when ccz_anf_implicit is True&#39;</span><span class="p">)</span>
        <span class="n">add_invertibility_equations</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">ignore_diagonal_equations</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">add_invertibility_equations</span> <span class="ow">is</span> <span class="kc">False</span>  <span class="c1"># l_c_linv not created when ignore_diagonal_equations</span>

    <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_mode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;list_coeffs&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;return_mode=&quot;list_coeffs&quot; not supported in find_self_equivalence&#39;</span><span class="p">)</span>

    <span class="n">initial_equations</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;initial_equations&quot;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">initial_fixed_vars</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;initial_fixed_vars&quot;</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">())</span>
    <span class="n">ignore_initial_parsing</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ignore_initial_parsing&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">check_find_fixed_vars</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;check_find_fixed_vars&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ignore_initial_parsing</span> <span class="ow">and</span> <span class="n">bpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bpr must be given if ignore_initial_parsing is True&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">initial_equations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_equations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">initial_fixed_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_fixed_vars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;finding SE (A, B) of F through the graph of G with deg(A), deg(B^(-1)) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;degrees </span><span class="si">{</span><span class="n">right_se_degree</span><span class="p">,</span> <span class="n">inv_left_se_degree</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;- F:&quot;</span><span class="p">)</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">input_anf_vars</span><span class="p">))</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- G (CCZ-</span><span class="si">{</span><span class="s1">&#39;implicit-&#39;</span> <span class="k">if</span> <span class="n">ccz_anf_implicit</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">equivalent of F):&quot;</span><span class="p">)</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">ccz_anf</span><span class="p">,</span> <span class="n">input_ccz_anf_vars</span><span class="p">))</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># 1 - Create C such that L C L^(-1) is diagonal</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | computing C&quot;</span><span class="p">)</span>

    <span class="c1"># use anf and input_anf_vars instead of ccz_anf and input_ccz_anf_vars</span>
    <span class="c1"># to consider also the case ccz_anf_implicit=True</span>
    <span class="n">num_c_input_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)</span>
    <span class="n">c_deg</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">right_se_degree</span><span class="p">,</span> <span class="n">inv_left_se_degree</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_varnames</span> <span class="o">=</span> <span class="n">bpr</span><span class="o">.</span><span class="n">variable_names</span><span class="p">()</span>
        <span class="n">num_total_symbolic_coeffs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_varnames</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_c_input_vars</span>

    <span class="k">if</span> <span class="n">ignore_initial_parsing</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ccz_se_anf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c_0</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">c_deg</span><span class="p">,</span> <span class="n">num_c_input_vars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">se_ct_terms</span><span class="p">,</span>
                                   <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_se_coeffs</span> <span class="o">+</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span>
                                   <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">coeff2expr</span><span class="o">=</span><span class="n">initial_fixed_vars</span><span class="p">)</span>
            <span class="n">c_1</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">c_deg</span><span class="p">,</span> <span class="n">num_c_input_vars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">se_ct_terms</span><span class="p">,</span>
                                   <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_se_coeffs</span> <span class="o">+</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span>
                                   <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">coeff2expr</span><span class="o">=</span><span class="n">initial_fixed_vars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccz_se_anf</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)</span>
            <span class="n">c_0</span><span class="p">,</span> <span class="n">c_1</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">(),</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="n">ccz_se_anf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="o">==</span> <span class="n">bpr</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">):</span>
                    <span class="n">c_0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccz_se_anf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccz_se_anf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">c_deg</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccz_anf</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccz_anf</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_se_coeffs</span> <span class="o">+</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span>
                                 <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">coeff2expr</span><span class="o">=</span><span class="n">initial_fixed_vars</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">c_0</span><span class="p">,</span> <span class="n">c_1</span><span class="p">):</span>
            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="n">c_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_c_input_vars</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ccz_se_anf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># cannot use coeff2ct since all coeffs are needed to build bpr</span>
            <span class="n">c_0</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">c_deg</span><span class="p">,</span> <span class="n">num_c_input_vars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">se_ct_terms</span><span class="p">,</span>
                                   <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_se_coeffs</span><span class="o">+</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
            <span class="n">c_1</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">c_deg</span><span class="p">,</span> <span class="n">num_c_input_vars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">se_ct_terms</span><span class="p">,</span>
                                   <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_se_coeffs</span><span class="o">+</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccz_se_anf</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)</span>
            <span class="n">c_0</span><span class="p">,</span> <span class="n">c_1</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">(),</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">):</span>
                    <span class="n">c_0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccz_se_anf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccz_se_anf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">c_deg</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccz_anf</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccz_anf</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_se_coeffs</span><span class="o">+</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_varnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">variable_names</span><span class="p">())</span>
            <span class="n">all_varnames</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vn</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">c_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">variable_names</span><span class="p">()</span> <span class="k">if</span> <span class="n">vn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_varnames</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initial_fixed_vars</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">symbolic_expression</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_varnames</span><span class="p">:</span>
                        <span class="n">all_varnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">initial_equations</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">symbolic_expression</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_varnames</span><span class="p">:</span>
                        <span class="n">all_varnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
                <span class="n">all_varnames</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vn</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">variable_names</span><span class="p">()</span> <span class="k">if</span> <span class="n">vn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_varnames</span><span class="p">)</span>
            <span class="n">num_total_symbolic_coeffs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_varnames</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_c_input_vars</span>
            <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;only_linear_fixed_vars&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;deglex&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;lex&quot;</span>
            <span class="n">bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_varnames</span><span class="p">),</span> <span class="n">all_varnames</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

        <span class="n">aux_ifv</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initial_fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">aux_ifv</span><span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">initial_fixed_vars</span> <span class="o">=</span> <span class="n">aux_ifv</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
        <span class="n">aux_c_0</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
        <span class="n">aux_c_1</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">c_0</span><span class="p">:</span>
            <span class="n">component</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">component</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">initial_fixed_vars</span><span class="p">))</span>
            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
            <span class="n">aux_c_0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">c_1</span><span class="p">:</span>
            <span class="n">component</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">component</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">initial_fixed_vars</span><span class="p">))</span>
            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
            <span class="n">aux_c_1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="n">c_0</span> <span class="o">=</span> <span class="n">aux_c_0</span>
        <span class="n">c_1</span> <span class="o">=</span> <span class="n">aux_c_1</span>

        <span class="n">c_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_c_input_vars</span><span class="p">)]</span>

        <span class="n">aux_ie</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">initial_equations</span><span class="p">:</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">initial_fixed_vars</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">eq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">eq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;found invalid initial equation 0 == 1&quot;</span><span class="p">)</span>
            <span class="n">aux_ie</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">initial_equations</span> <span class="o">=</span> <span class="n">aux_ie</span>

        <span class="k">if</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
            <span class="n">aux_d</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">component</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">component</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">initial_fixed_vars</span><span class="p">))</span>
                <span class="n">aux_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">aux_d</span>

        <span class="n">aux_ccz_anf</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">ccz_anf</span><span class="p">:</span>
            <span class="n">aux_ccz_anf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>
        <span class="n">ccz_anf</span> <span class="o">=</span> <span class="n">aux_ccz_anf</span>

        <span class="n">input_ccz_anf_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">input_ccz_anf_vars</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;- C (self-equivalence of Graph(G)):&quot;</span><span class="p">)</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;number of C input variables:&quot;</span><span class="p">,</span> <span class="n">num_c_input_vars</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;number of symbolic coefficients:&quot;</span><span class="p">,</span> <span class="n">num_total_symbolic_coeffs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_fixed_vars</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;number of initial fixed vars:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_fixed_vars</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">initial_equations</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;number of initial equations:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input variables (</span><span class="si">{</span><span class="n">num_c_input_vars</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">all_varnames</span><span class="p">[:</span><span class="n">num_c_input_vars</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;symbolic coefficients (</span><span class="si">{</span><span class="n">num_total_symbolic_coeffs</span><span class="si">}</span><span class="s2">): &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">all_varnames</span><span class="p">[</span><span class="o">-</span><span class="n">num_total_symbolic_coeffs</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="n">bpr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_fixed_vars</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;initial fixed vars (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_fixed_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initial_fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> &lt;- </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_equations</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;initial equations (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">initial_equations</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">_sp</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;- D (from G = D G C):&quot;</span><span class="p">)</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ccz_anf</span><span class="p">))]))</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># 1.2  Getting the equations L C L^(-1) = diagonal</span>

    <span class="n">equations</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span>
    <span class="n">cvar2index</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c_input_vars</span><span class="p">)}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_diagonal_equations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">right_se_degree</span> <span class="o">&lt;</span> <span class="n">c_deg</span> <span class="ow">or</span> <span class="n">inv_left_se_degree</span> <span class="o">&lt;</span> <span class="n">c_deg</span><span class="p">:</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; with top/bottom degrees </span><span class="si">{</span><span class="n">right_se_degree</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">inv_left_se_degree</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | getting equations from L C L^(-1) = diagonal</span><span class="si">{</span><span class="n">aux</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">is_Matrix</span>
        <span class="k">if</span> <span class="n">is_Matrix</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">):</span>
            <span class="n">am_anf</span> <span class="o">=</span> <span class="n">matrix2anf</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">,</span> <span class="n">bool_poly_ring</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">)</span>
            <span class="n">am_matrix</span> <span class="o">=</span> <span class="n">admissible_mapping</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">is_Matrix</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">bit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;affine admissible mappings not supported&quot;</span><span class="p">)</span>
            <span class="n">am_anf</span> <span class="o">=</span> <span class="n">matrix2anf</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bool_poly_ring</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span>
                                <span class="n">input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">,</span> <span class="n">bin_vector</span><span class="o">=</span><span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">am_matrix</span> <span class="o">=</span> <span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">am_anf</span> <span class="o">=</span> <span class="n">admissible_mapping</span>
            <span class="n">am_matrix</span> <span class="o">=</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_input_vars</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">get_ct_coeff</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_input_vars</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;affine admissible mappings not supported&quot;</span><span class="p">)</span>

        <span class="n">inv_am_anf</span> <span class="o">=</span> <span class="n">matrix2anf</span><span class="p">(</span><span class="n">am_matrix</span><span class="o">.</span><span class="n">inverse</span><span class="p">(),</span> <span class="n">bool_poly_ring</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">6</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">missing_anf</span><span class="p">:</span>  <span class="c1"># complexity 2^12</span>
            <span class="n">inv_am_matrix</span> <span class="o">=</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">inv_am_anf</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">)</span> <span class="k">if</span> <span class="n">ccz_anf_implicit</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
                <span class="n">result_check</span> <span class="o">=</span> <span class="n">check_ccz_equivalence_anf</span><span class="p">(</span>
                    <span class="n">ccz_anf</span><span class="p">,</span> <span class="n">anf</span><span class="p">,</span> <span class="n">am_matrix</span><span class="p">,</span>
                    <span class="n">f_input_vars</span><span class="o">=</span><span class="n">input_ccz_anf_vars</span><span class="p">,</span> <span class="n">g_input_vars</span><span class="o">=</span><span class="n">input_anf_vars</span><span class="p">,</span> <span class="n">a_input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result_check</span> <span class="o">=</span> <span class="n">check_ccz_equivalence_anf</span><span class="p">(</span>
                    <span class="n">anf</span><span class="p">,</span> <span class="n">ccz_anf</span><span class="p">,</span> <span class="n">inv_am_matrix</span><span class="p">,</span> <span class="n">g_implicit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">f_input_vars</span><span class="o">=</span><span class="n">input_anf_vars</span><span class="p">,</span> <span class="n">g_input_vars</span><span class="o">=</span><span class="n">input_ccz_anf_vars</span><span class="p">,</span> <span class="n">a_input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result_check</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;L(Graph(G)) != Graph(F)&quot;</span><span class="p">)</span>

        <span class="n">l_c_linv</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">{</span><span class="n">c_input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">inv_am_anf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_c_input_vars</span><span class="p">)},</span> <span class="n">bpr</span><span class="p">)</span>
        <span class="n">l_c_linv</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">am_anf</span><span class="p">,</span> <span class="p">{</span><span class="n">c_input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">l_c_linv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_c_input_vars</span><span class="p">)},</span> <span class="n">bpr</span><span class="p">)</span>
        <span class="n">l_c_linv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">l_c_linv</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;- L C L^(-1) (L admissible mapping L(Graph(G)=Graph(F)):&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">l_c_linv</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">right_se_degree</span> <span class="o">&lt;</span> <span class="n">c_deg</span> <span class="ow">or</span> <span class="n">inv_left_se_degree</span> <span class="o">&lt;</span> <span class="n">c_deg</span><span class="p">:</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; with degrees </span><span class="si">{</span><span class="n">right_se_degree</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">inv_left_se_degree</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;equations from L C L^(-1) = diagonal</span><span class="si">{</span><span class="n">aux</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>

        <span class="n">index_eq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index_component</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l_c_linv</span><span class="p">):</span>
            <span class="n">all_coeffs</span> <span class="o">=</span> <span class="n">get_all_symbolic_coeff</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">monomial</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">all_coeffs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">monomial_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">monomial</span><span class="o">.</span><span class="n">variables</span><span class="p">()]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomial_vars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">index_component</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="ow">and</span> <span class="n">monomial</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">right_se_degree</span><span class="p">)</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="n">index_component</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="ow">and</span> <span class="n">monomial</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">inv_left_se_degree</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;L C L^(-1) has different degree, </span><span class="si">{</span><span class="n">index_component</span><span class="si">}</span><span class="s2">-th component &quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;has monomial </span><span class="si">{</span><span class="n">monomial</span><span class="si">}</span><span class="s2"> with non-zero coeff </span><span class="si">{</span><span class="n">coeff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">eq[</span><span class="si">{</span><span class="n">index_eq</span><span class="si">}</span><span class="s2">]: (</span><span class="si">{</span><span class="n">index_component</span><span class="si">}</span><span class="s2">-th component) &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;0 == coefficient(monomial/degree=</span><span class="si">{</span><span class="n">monomial</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">monomial</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                    <span class="n">index_eq</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># for first len(input_anf_vars) components,</span>
                <span class="c1"># only monomials involving the first len(input_anf_vars) variables</span>
                <span class="c1"># for the rest, only monomials involving the remaining variables</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">index_component</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">(</span><span class="n">cvar2index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">monomial_vars</span><span class="p">))</span> <span class="ow">or</span> \
                        <span class="p">(</span><span class="n">index_component</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="ow">and</span>
                         <span class="nb">any</span><span class="p">(</span><span class="n">cvar2index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">monomial_vars</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;L C L^(-1) cannot be diagonal, </span><span class="si">{</span><span class="n">index_component</span><span class="si">}</span><span class="s2">-th component &quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;has monomial </span><span class="si">{</span><span class="n">monomial</span><span class="si">}</span><span class="s2"> with non-zero coeff </span><span class="si">{</span><span class="n">coeff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">eq[</span><span class="si">{</span><span class="n">index_eq</span><span class="si">}</span><span class="s2">]: (</span><span class="si">{</span><span class="n">index_component</span><span class="si">}</span><span class="s2">-th component) &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;0 == coefficient(monomial=</span><span class="si">{</span><span class="n">monomial</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                    <span class="n">index_eq</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;no equations added from L C L^(-1) = diagonal&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># 1.5 - Reducing initial and diagonal equations</span>

    <span class="c1"># no calls to find_fixed_vars() when &quot;raw_equations&quot; mode</span>
    <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_mode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;raw_equations&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_diagonal_equations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | finding fixed variables and reducing initial and diagonal equations&quot;</span><span class="p">)</span>

        <span class="n">reduction_mode</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reduction_mode&quot;</span><span class="p">,</span> <span class="s2">&quot;gauss&quot;</span><span class="p">)</span>
        <span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">equations</span> <span class="o">=</span> <span class="n">find_fixed_vars</span><span class="p">(</span>
            <span class="n">equations</span><span class="p">,</span> <span class="n">only_linear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">initial_r_mode</span><span class="o">=</span><span class="n">reduction_mode</span><span class="p">,</span> <span class="n">repeat_with_r_mode</span><span class="o">=</span><span class="n">reduction_mode</span><span class="p">,</span>
            <span class="n">initial_fixed_vars</span><span class="o">=</span><span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check_find_fixed_vars</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">l_c_linv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">substitute_anf</span><span class="p">(</span><span class="n">l_c_linv</span><span class="p">,</span> <span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">))</span>  <span class="c1"># to list to be sliced</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;- L C L^(-1) (reduced by initial and diagonal equations):&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">l_c_linv</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># 2 - Add invertibility equations imposed over L C L^(-1)</span>

    <span class="n">len_eqs_b4_inv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">add_invertibility_equations</span><span class="p">:</span>
        <span class="c1">#   create a new LCL^(-1) with linear vars from diagonal_equations + initial_equations</span>
        <span class="c1">#   if A or B^(-1) is of degree 1, then add the determinant equation</span>
        <span class="c1">#   otherwise, add find_inverse equations from the one whose inverse degree is given</span>
        <span class="c1">#   finally save the invertibility equations and ignore the reduced LCL^(-1)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | adding invertibility equations over L C L^(-1)&quot;</span><span class="p">)</span>

        <span class="n">inv_equations</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>

        <span class="c1"># first part tries to get easy fixed variables from sparse row/columns</span>
        <span class="c1"># nrows = num output vars, ncols = num inputs vars</span>

        <span class="c1"># depth is computed as follows:</span>
        <span class="c1">#   sum_{i=0}^{k} binom(n,i) &lt; n^k + 1  (k == depth, n == nrows == num components)</span>
        <span class="c1">#   n^k &lt;= 2^16 (max complexity) &lt;==&gt; k = k log(n,n) &lt;= log(2^16, n)</span>

        <span class="k">if</span> <span class="n">inv_left_se_degree</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">base_matrix</span> <span class="o">=</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">l_c_linv</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">):],</span> <span class="n">c_input_vars</span><span class="p">)</span><span class="o">.</span><span class="n">submatrix</span><span class="p">(</span><span class="n">col</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">base_matrix</span><span class="o">.</span><span class="n">is_square</span><span class="p">()</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">,</span> <span class="n">base_matrix</span><span class="o">.</span><span class="n">nrows</span><span class="p">()))</span>
            <span class="n">aux_iv</span> <span class="o">=</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="p">[</span><span class="n">base_matrix</span><span class="p">,</span> <span class="n">base_matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">()]:</span>
                <span class="n">matrix_anf</span> <span class="o">=</span> <span class="n">matrix2anf</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">bool_poly_ring</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">aux_iv</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">_get_lowdeg_inv_equations</span><span class="p">(</span><span class="n">matrix_anf</span><span class="p">,</span> <span class="n">bpr</span><span class="p">,</span> <span class="n">max_deg</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">aux_iv</span><span class="p">):</span>
                    <span class="n">inv_equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aux_anf</span> <span class="o">=</span> <span class="n">l_c_linv</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">):]</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">_get_lowdeg_inv_equations</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">,</span> <span class="n">bpr</span><span class="p">,</span> <span class="n">max_deg</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">):</span>
                <span class="n">inv_equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">right_se_degree</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">base_matrix</span> <span class="o">=</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">l_c_linv</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)],</span> <span class="n">c_input_vars</span><span class="p">)</span><span class="o">.</span><span class="n">submatrix</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">base_matrix</span><span class="o">.</span><span class="n">is_square</span><span class="p">()</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">,</span> <span class="n">base_matrix</span><span class="o">.</span><span class="n">nrows</span><span class="p">()))</span>
            <span class="n">aux_iv</span> <span class="o">=</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="p">[</span><span class="n">base_matrix</span><span class="p">,</span> <span class="n">base_matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">()]:</span>
                <span class="n">matrix_anf</span> <span class="o">=</span> <span class="n">matrix2anf</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">bool_poly_ring</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">aux_iv</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">_get_lowdeg_inv_equations</span><span class="p">(</span><span class="n">matrix_anf</span><span class="p">,</span> <span class="n">bpr</span><span class="p">,</span> <span class="n">max_deg</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">aux_iv</span><span class="p">):</span>
                    <span class="n">inv_equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aux_anf</span> <span class="o">=</span> <span class="n">l_c_linv</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)]</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">_get_lowdeg_inv_equations</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">,</span> <span class="n">bpr</span><span class="p">,</span> <span class="n">max_deg</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">):</span>
                <span class="n">inv_equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

        <span class="c1"># second part adds the determinant constraint to base_matrix = right A</span>
        <span class="c1"># no calls to find_fixed_vars() when &quot;raw_equations&quot; mode</span>

        <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_mode&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;raw_equations&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_determinant_equation</span><span class="p">:</span>
            <span class="n">reduction_mode</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;reduction_mode&quot;</span><span class="p">,</span> <span class="s2">&quot;gauss&quot;</span><span class="p">)</span>
            <span class="n">inv_fixed_vars</span><span class="p">,</span> <span class="n">inv_equations</span> <span class="o">=</span> <span class="n">find_fixed_vars</span><span class="p">(</span>
                <span class="n">inv_equations</span><span class="p">,</span> <span class="n">only_linear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">initial_r_mode</span><span class="o">=</span><span class="n">reduction_mode</span><span class="p">,</span> <span class="n">repeat_with_r_mode</span><span class="o">=</span><span class="n">reduction_mode</span><span class="p">,</span>
                <span class="n">initial_fixed_vars</span><span class="o">=</span><span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check_find_fixed_vars</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_fixed_vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_fixed_vars</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)):</span>
                    <span class="n">equations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">equations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">inv_fixed_vars</span><span class="p">)</span>
                <span class="n">base_matrix</span> <span class="o">=</span> <span class="n">base_matrix</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">inv_fixed_vars</span><span class="p">)</span>
            <span class="n">initial_fixed_vars</span> <span class="o">=</span> <span class="n">inv_fixed_vars</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">inv_equations</span><span class="p">:</span>
                <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
            <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">base_matrix</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span> <span class="o">+</span> <span class="n">bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">inv_equations</span><span class="p">:</span>
                <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span><span class="o">-</span><span class="n">len_eqs_b4_inv</span><span class="si">}</span><span class="s2"> invertibility equations&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_eqs_b4_inv</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)):</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">equations</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># 3 - Find a Graph(G)-SE of G</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | solving the Graph(G)-self-equivalence functional equation&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
        <span class="c1">#  G(c_0(u, G(u))) = c_1(u, G(u)))</span>
        <span class="n">c_0</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">c_0</span><span class="p">,</span> <span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
        <span class="n">c_1</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">c_1</span><span class="p">,</span> <span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">ccz_anf</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">c_0</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">input_ccz_anf_vars</span><span class="p">,</span> <span class="n">ccz_anf</span><span class="p">):</span>
            <span class="n">f0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="n">f2_input_vars</span> <span class="o">=</span> <span class="n">input_ccz_anf_vars</span>
        <span class="n">f1_input_vars</span> <span class="o">=</span> <span class="n">c_input_vars</span>
        <span class="n">f0_input_vars</span> <span class="o">=</span> <span class="n">input_ccz_anf_vars</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">c_1</span>
        <span class="n">g0</span> <span class="o">=</span> <span class="n">f0</span>
        <span class="n">g1_input_vars</span> <span class="o">=</span> <span class="n">c_input_vars</span>
        <span class="n">g0_input_vars</span> <span class="o">=</span> <span class="n">f0_input_vars</span>
        <span class="n">lhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">]</span>
        <span class="n">lhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0_input_vars</span><span class="p">,</span> <span class="n">f1_input_vars</span><span class="p">,</span> <span class="n">f2_input_vars</span><span class="p">]</span>
        <span class="n">rhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0</span><span class="p">,</span> <span class="n">g1</span><span class="p">]</span>
        <span class="n">rhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0_input_vars</span><span class="p">,</span> <span class="n">g1_input_vars</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># D G C  = G</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">d</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">ccz_anf</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">f2_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ccz_anf</span><span class="p">))]</span>
        <span class="n">f1_input_vars</span> <span class="o">=</span> <span class="n">input_ccz_anf_vars</span>
        <span class="n">f0_input_vars</span> <span class="o">=</span> <span class="n">c_input_vars</span>
        <span class="n">g0</span> <span class="o">=</span> <span class="n">ccz_anf</span>
        <span class="n">g0_input_vars</span> <span class="o">=</span> <span class="n">f1_input_vars</span>
        <span class="n">lhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">]</span>
        <span class="n">lhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0_input_vars</span><span class="p">,</span> <span class="n">f1_input_vars</span><span class="p">,</span> <span class="n">f2_input_vars</span><span class="p">]</span>
        <span class="n">rhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0</span><span class="p">]</span>
        <span class="n">rhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0_input_vars</span><span class="p">]</span>

    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;num_sat_solutions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_mode must be specified if num_sat_solutions is&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;list_anfs&quot;</span>

    <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;ignore_initial_parsing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;initial_equations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">equations</span>
    <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;initial_fixed_vars&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_fixed_vars</span>

    <span class="k">if</span> <span class="s2">&quot;find_redundant_equations&quot;</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">aux_fre</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;find_redundant_equations&quot;</span><span class="p">]:</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">initial_fixed_vars</span><span class="p">))</span>
            <span class="n">aux_fre</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;find_redundant_equations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_fre</span>

    <span class="k">if</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;ignore_varnames&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">vn</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">all_varnames</span> <span class="k">if</span> <span class="n">vn</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_se_coeffs</span> <span class="o">+</span> <span class="s2">&quot;d&quot;</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">initial_fixed_vars</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_se_coeffs</span><span class="o">+</span><span class="s2">&quot;d&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;removing from initial_fixed_vars </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> &lt;- </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">initial_fixed_vars</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">graph_solutions</span> <span class="o">=</span> <span class="n">solve_functional_equation</span><span class="p">(</span>
            <span class="n">lhs_anfs</span><span class="p">,</span> <span class="n">rhs_anfs</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="sa">f</span><span class="s2">&quot;No solution found (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># 4 - Parsing and checking L C L^(-1) is a SE of F for one solution</span>

    <span class="k">if</span> <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;raw_equations&quot;</span><span class="p">,</span> <span class="s2">&quot;lincomb_solutions&quot;</span><span class="p">]</span> \
            <span class="ow">or</span> <span class="n">new_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;find_redundant_equations&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">graph_solutions</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | parsing </span><span class="si">{</span><span class="s1">&#39;and checking&#39;</span> <span class="k">if</span> <span class="n">check_se</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;the Graph(G)-self-equivalence solutions&quot;</span><span class="p">)</span>

    <span class="n">se_solutions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">extra_var2val</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">symbolic_coeffs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;list_anfs&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph_solutions</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_total_num_solutions&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">se_solutions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graph_solutions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">se_solutions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graph_solutions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;symbolic_anf&quot;</span><span class="p">,</span> <span class="s2">&quot;symbolic_coeffs&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;symbolic_anf&quot;</span><span class="p">:</span>
            <span class="n">se_solutions</span> <span class="o">=</span> <span class="p">[</span><span class="n">graph_solutions</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symbolic_coeffs</span> <span class="o">=</span> <span class="n">graph_solutions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
                <span class="c1"># se_solutions[0][0][1] == c_0, se_solutions[0][1][1] == g1</span>
                <span class="n">se_solutions</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[</span>
                        <span class="p">[</span>
                            <span class="kc">None</span><span class="p">,</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">c_0</span><span class="p">,</span> <span class="n">symbolic_coeffs</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                        <span class="p">],</span>  <span class="c1"># se_solutions[0][0]</span>
                        <span class="p">[</span>
                            <span class="kc">None</span><span class="p">,</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">c_1</span><span class="p">,</span> <span class="n">symbolic_coeffs</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                        <span class="p">]</span>  <span class="c1"># se_solutions[0][1]</span>
                    <span class="p">]</span>  <span class="c1"># se_solutions[0]</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># se_solutions[0][0][0] == c</span>
                <span class="n">se_solutions</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[</span>
                        <span class="p">[</span>
                            <span class="n">substitute_anf</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">symbolic_coeffs</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                        <span class="p">]</span> <span class="c1"># se_solutions[0][0]</span>
                    <span class="p">]</span> <span class="c1"># se_solutions[0]</span>
                <span class="p">]</span>

        <span class="k">if</span> <span class="n">check_se</span><span class="p">:</span>
            <span class="n">extra_equations</span> <span class="o">=</span> <span class="n">graph_solutions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">extra_equations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;finding a solution of the remaining </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">extra_equations</span><span class="p">)</span><span class="si">}</span><span class="s2"> equations for checking&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">extra_equations</span><span class="p">:</span>
                            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">extra_var2val</span> <span class="o">=</span> <span class="n">solve_sat</span><span class="p">(</span><span class="n">extra_equations</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s_threads</span><span class="o">=</span><span class="n">new_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;threads&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">extra_var2val</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;equations from &quot;symbolic_anf&quot; output are inconsistent (unsatisfiable)&#39;</span><span class="p">)</span>
                <span class="n">extra_var2val</span> <span class="o">=</span> <span class="p">{</span><span class="n">bpr</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">extra_var2val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>  <span class="c1"># first solution</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; - solution: </span><span class="si">{</span><span class="n">extra_var2val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">free_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
                <span class="n">aux_loop</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">se_solutions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">se_solutions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux_loop</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">se_solutions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">aux_anf</span> <span class="ow">in</span> <span class="n">aux_loop</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">aux_anf</span><span class="p">:</span>  <span class="c1"># avoid anf</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">component</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                        <span class="n">var</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c_input_vars</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">extra_var2val</span><span class="p">:</span>
                            <span class="n">free_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">free_vars</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;setting to 0 the free variables </span><span class="si">{</span><span class="n">free_vars</span><span class="si">}</span><span class="s2"> for checking&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">free_vars</span><span class="p">:</span>
                    <span class="n">extra_var2val</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ignore_diagonal_equations</span> <span class="ow">and</span> <span class="p">(</span><span class="n">check_se</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">return_ccz_se</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sage.structure.element</span> <span class="kn">import</span> <span class="n">is_Matrix</span>
        <span class="k">if</span> <span class="n">is_Matrix</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">):</span>
            <span class="n">am_anf</span> <span class="o">=</span> <span class="n">matrix2anf</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">,</span> <span class="n">bool_poly_ring</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">)</span>
            <span class="n">am_matrix</span> <span class="o">=</span> <span class="n">admissible_mapping</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">is_Matrix</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">bit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;affine admissible mappings not supported&quot;</span><span class="p">)</span>
            <span class="n">am_anf</span> <span class="o">=</span> <span class="n">matrix2anf</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bool_poly_ring</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span>
                                <span class="n">input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">,</span> <span class="n">bin_vector</span><span class="o">=</span><span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">am_matrix</span> <span class="o">=</span> <span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">am_anf</span> <span class="o">=</span> <span class="n">admissible_mapping</span>
            <span class="n">am_matrix</span> <span class="o">=</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_input_vars</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">get_ct_coeff</span><span class="p">(</span><span class="n">admissible_mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_input_vars</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;affine admissible mappings not supported&quot;</span><span class="p">)</span>

        <span class="n">inv_am_anf</span> <span class="o">=</span> <span class="n">matrix2anf</span><span class="p">(</span><span class="n">am_matrix</span><span class="o">.</span><span class="n">inverse</span><span class="p">(),</span> <span class="n">bool_poly_ring</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">index_se_sol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">se_solutions</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
            <span class="n">c_0_sol</span> <span class="o">=</span> <span class="n">se_solutions</span><span class="p">[</span><span class="n">index_se_sol</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># f1</span>
            <span class="n">c_1_sol</span> <span class="o">=</span> <span class="n">se_solutions</span><span class="p">[</span><span class="n">index_se_sol</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># g1</span>
            <span class="n">c_sol</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">c_0_sol</span><span class="p">,</span> <span class="n">c_1_sol</span><span class="p">):</span>
                <span class="n">c_sol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_sol</span> <span class="o">=</span> <span class="n">se_solutions</span><span class="p">[</span><span class="n">index_se_sol</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># f0</span>

        <span class="k">if</span> <span class="n">return_ccz_se</span><span class="p">:</span>
            <span class="n">se_solutions</span><span class="p">[</span><span class="n">index_se_sol</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_sol</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check_se</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">debug</span><span class="p">):</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solution </span><span class="si">{</span><span class="n">index_se_sol</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">se_solutions</span><span class="p">)</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_se</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">6</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ccz_anf_implicit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extra_var2val</span><span class="p">:</span>
                <span class="n">c_sol_fixed</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">c_sol</span><span class="p">,</span> <span class="n">extra_var2val</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">debug</span><span class="p">):</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- C:&quot;</span><span class="p">)</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">c_sol</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">))</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- C (with </span><span class="si">{</span><span class="n">extra_var2val</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">c_sol_fixed</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_sol_fixed</span> <span class="o">=</span> <span class="n">c_sol</span>
            <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c_input_vars</span><span class="p">])</span>
            <span class="n">c_sol_fixed</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">c_sol_fixed</span><span class="p">]</span>
            <span class="c1"># if not check_ccz_equivalence_anf(ccz_anf_simple_bpr, ccz_anf_simple_bpr, c_sol_fixed):</span>
            <span class="n">result_check</span> <span class="o">=</span> <span class="n">check_ccz_equivalence_anf</span><span class="p">(</span>
                <span class="n">ccz_anf</span><span class="p">,</span> <span class="n">ccz_anf</span><span class="p">,</span> <span class="n">c_sol_fixed</span><span class="p">,</span>
                <span class="n">f_input_vars</span><span class="o">=</span><span class="n">input_ccz_anf_vars</span><span class="p">,</span> <span class="n">g_input_vars</span><span class="o">=</span><span class="n">input_ccz_anf_vars</span><span class="p">,</span> <span class="n">a_input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result_check</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;C is not a Graph-SE of G&quot;</span><span class="p">)</span>

        <span class="n">l_c_linv_sol</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span>
            <span class="n">c_sol</span><span class="p">,</span> <span class="p">{</span><span class="n">c_input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">inv_am_anf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_c_input_vars</span><span class="p">)},</span> <span class="n">bpr</span><span class="p">)</span>
        <span class="n">l_c_linv_sol</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span>
            <span class="n">am_anf</span><span class="p">,</span> <span class="p">{</span><span class="n">c_input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">l_c_linv_sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_c_input_vars</span><span class="p">)},</span> <span class="n">bpr</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">debug</span><span class="p">):</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- L C L^(-1):&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">l_c_linv_sol</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">check_se</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extra_var2val</span><span class="p">:</span>
                <span class="n">l_c_linv_sol_fixed</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">l_c_linv_sol</span><span class="p">,</span> <span class="n">extra_var2val</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">debug</span><span class="p">):</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- L C L^(-1) (with </span><span class="si">{</span><span class="n">extra_var2val</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">l_c_linv_sol_fixed</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l_c_linv_sol_fixed</span> <span class="o">=</span> <span class="n">l_c_linv_sol</span>

            <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c_input_vars</span><span class="p">])</span>
            <span class="n">l_c_linv_sol_fixed</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">l_c_linv_sol_fixed</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">6</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">missing_anf</span><span class="p">:</span>  <span class="c1"># complexity 2^12</span>
                <span class="c1"># if not check_ccz_equivalence_anf(anf_simple_bpr, anf_simple_bpr, l_c_linv_sol_fixed):</span>
                <span class="n">result_check</span> <span class="o">=</span> <span class="n">check_ccz_equivalence_anf</span><span class="p">(</span>
                    <span class="n">anf</span><span class="p">,</span> <span class="n">anf</span><span class="p">,</span> <span class="n">l_c_linv_sol_fixed</span><span class="p">,</span>
                    <span class="n">f_input_vars</span><span class="o">=</span><span class="n">input_anf_vars</span><span class="p">,</span> <span class="n">g_input_vars</span><span class="o">=</span><span class="n">input_anf_vars</span><span class="p">,</span> <span class="n">a_input_vars</span><span class="o">=</span><span class="n">c_input_vars</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result_check</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;L C L^(-1) is not a Graph-SE of F&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">c_deg</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">l_c_linv_sol_fixed</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">)</span><span class="o">.</span><span class="n">is_invertible</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;L C L^(-1) is not invertible&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_input_vars</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_invertible</span><span class="p">(</span><span class="n">anf2lut</span><span class="p">(</span><span class="n">l_c_linv_sol_fixed</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;L C L^(-1) is not invertible&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">index_component</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l_c_linv_sol_fixed</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">monomial</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">get_all_symbolic_coeff</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">monomial_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">monomial</span><span class="o">.</span><span class="n">variables</span><span class="p">()]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomial_vars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">index_component</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="ow">and</span> <span class="n">monomial</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">right_se_degree</span><span class="p">)</span> <span class="ow">or</span> \
                            <span class="p">(</span><span class="n">index_component</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="ow">and</span> <span class="n">monomial</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">inv_left_se_degree</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;L C L^(-1) (from </span><span class="si">{</span><span class="n">index_se_sol</span><span class="si">}</span><span class="s2">-th solution) has different degree, &quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index_component</span><span class="si">}</span><span class="s2">-th component has monomial </span><span class="si">{</span><span class="n">monomial</span><span class="si">}</span><span class="s2"> &quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot;with non-zero coeff </span><span class="si">{</span><span class="n">coeff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">index_component</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="nb">any</span><span class="p">(</span><span class="n">cvar2index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">monomial_vars</span><span class="p">))</span> <span class="ow">or</span> \
                            <span class="p">(</span><span class="n">index_component</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="ow">and</span>
                             <span class="nb">any</span><span class="p">(</span><span class="n">cvar2index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">monomial_vars</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;L C L^(-1) (from </span><span class="si">{</span><span class="n">index_se_sol</span><span class="si">}</span><span class="s2">-th solution) is not diagonal, &quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index_component</span><span class="si">}</span><span class="s2">-th component has monomial </span><span class="si">{</span><span class="n">monomial</span><span class="si">}</span><span class="s2"> &quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot;with non-zero coeff </span><span class="si">{</span><span class="n">coeff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">l_c_linv_sol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">l_c_linv_sol</span><span class="p">)</span>  <span class="c1"># to be sliced</span>

        <span class="n">aux_rep</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">bpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c_input_vars</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">):]}</span>
        <span class="n">a_sol</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">l_c_linv_sol</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)],</span> <span class="n">aux_rep</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
        <span class="n">aux_rep</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_c_input_vars</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">):</span>
                <span class="n">aux_rep</span><span class="p">[</span><span class="n">c_input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux_rep</span><span class="p">[</span><span class="n">c_input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">c_input_vars</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)]</span>
        <span class="n">b_inv_sol</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">l_c_linv_sol</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">):],</span> <span class="n">aux_rep</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">debug</span><span class="p">):</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- SE (A, B) of F:&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot; - A:&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">a_sol</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)]))</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot; - B^(-1):&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">b_inv_sol</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)]))</span>

        <span class="k">if</span> <span class="n">check_se</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extra_var2val</span><span class="p">:</span>
                <span class="n">a_sol_fixed</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">a_sol</span><span class="p">,</span> <span class="n">extra_var2val</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                <span class="n">b_inv_sol_fixed</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">b_inv_sol</span><span class="p">,</span> <span class="n">extra_var2val</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">index_se_sol</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">debug</span><span class="p">):</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- SE (A, B) of F (with </span><span class="si">{</span><span class="n">extra_var2val</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot; - A:&quot;</span><span class="p">)</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">a_sol_fixed</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)]))</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot; - B^(-1):&quot;</span><span class="p">)</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">b_inv_sol_fixed</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a_sol_fixed</span> <span class="o">=</span> <span class="n">a_sol</span>
                <span class="n">b_inv_sol_fixed</span> <span class="o">=</span> <span class="n">b_inv_sol</span>

            <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)]])</span>
            <span class="n">a_sol_fixed</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">a_sol_fixed</span><span class="p">]</span>
            <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)]])</span>
            <span class="n">b_inv_sol_fixed</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">b_inv_sol_fixed</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">right_se_degree</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">a_sol_fixed</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)])</span><span class="o">.</span><span class="n">is_invertible</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A is not invertible&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_invertible</span><span class="p">(</span><span class="n">anf2lut</span><span class="p">(</span><span class="n">a_sol_fixed</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A is not invertible&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inv_left_se_degree</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">b_inv_sol_fixed</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)])</span><span class="o">.</span><span class="n">is_invertible</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;B is not invertible&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_invertible</span><span class="p">(</span><span class="n">anf2lut</span><span class="p">(</span><span class="n">b_inv_sol_fixed</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;B is not invertible&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">missing_anf</span><span class="p">:</span>
                <span class="c1"># lhs = compose_anf_fast(b_inv_sol_fixed, anf_simple_bpr)</span>
                <span class="c1"># rhs = compose_anf_fast(anf_simple_bpr, a_sol_fixed)</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">b_inv_sol_fixed</span><span class="p">,</span> <span class="p">{</span><span class="n">c_input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">f</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">anf</span><span class="p">)},</span> <span class="n">bpr</span><span class="p">)</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="p">{</span><span class="n">input_anf_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">f</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_sol_fixed</span><span class="p">)},</span> <span class="n">bpr</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">lhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="p">))):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;B^(-1) F != F A (from </span><span class="si">{</span><span class="n">index_se_sol</span><span class="si">}</span><span class="s2">-th solution):</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;- B^(-1) F: </span><span class="se">\n</span><span class="si">{</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)])</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;- F A: </span><span class="se">\n</span><span class="si">{</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">c_input_vars</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)])</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_ccz_se</span><span class="p">:</span>
            <span class="n">se_solutions</span><span class="p">[</span><span class="n">index_se_sol</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a_sol</span><span class="p">,</span> <span class="n">b_inv_sol</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># 5 - Output</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | returning outputs with mode=&#39;</span><span class="si">{</span><span class="n">new_kwargs</span><span class="p">[</span><span class="s1">&#39;return_mode&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span> <span class="ow">and</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_total_num_solutions&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;ignoring return_total_num_solutions&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">se_solutions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">new_kwargs</span><span class="p">[</span><span class="s1">&#39;return_mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;list_anfs&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_total_num_solutions&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">se_solutions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">se_solutions</span><span class="p">,</span> <span class="n">graph_solutions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">new_kwargs</span><span class="p">[</span><span class="s1">&#39;return_mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;symbolic_anf&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">se_solutions</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph_solutions</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">new_kwargs</span><span class="p">[</span><span class="s1">&#39;return_mode&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;symbolic_coeffs&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">symbolic_coeffs</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph_solutions</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span></div>


<span class="k">def</span> <span class="nf">_get_lowdeg_inv_equations</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">bpr</span><span class="p">,</span> <span class="n">max_deg</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">input_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get some low degree invertibility constraints from a symbolic anf.</span>

<span class="sd">        &gt;&gt;&gt; bpr = BooleanPolynomialRing(names=(&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;))</span>
<span class="sd">        &gt;&gt;&gt; x, y, z, a, b, c, d, e, f = bpr.gens()</span>
<span class="sd">        &gt;&gt;&gt; matrix = sage.all.matrix(bpr, 3, 3, [[a, b, 0], [c, 0, d], [0, e, f]])</span>
<span class="sd">        &gt;&gt;&gt; matrix.determinant() + 1</span>
<span class="sd">        a*d*e + b*c*f + 1</span>
<span class="sd">        &gt;&gt;&gt; bin_vector = [a, b, c]</span>
<span class="sd">        &gt;&gt;&gt; anf = matrix2anf(matrix, bool_poly_ring=bpr, input_vars=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;], bin_vector=bin_vector)</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(anf, input_vars=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;])</span>
<span class="sd">        [x y z|1]</span>
<span class="sd">        [-----+-]</span>
<span class="sd">        [a b 0|a]</span>
<span class="sd">        [c 0 d|b]</span>
<span class="sd">        [0 e f|c]</span>
<span class="sd">        &gt;&gt;&gt; for eq in _get_lowdeg_inv_equations(anf, bpr, max_deg=2, input_vars=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]): print(_sp(eq))</span>
<span class="sd">        a*b + a + b + 1</span>
<span class="sd">        c*d + c + d + 1</span>
<span class="sd">        e*f + e + f + 1</span>
<span class="sd">        &gt;&gt;&gt; anf = [a*x*y + b*x, c*x*y + d*a + e*z]</span>
<span class="sd">        &gt;&gt;&gt; for eq in _get_lowdeg_inv_equations(anf, bpr, max_deg=2, input_vars=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]): print(_sp(eq))</span>
<span class="sd">        a</span>
<span class="sd">        b + 1</span>
<span class="sd">        e + 1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">input_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">aux_bpr</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">anf</span><span class="p">)</span>
        <span class="n">input_vars</span> <span class="o">=</span> <span class="n">aux_bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">or_bits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">vectorindex2_component</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">canonical_vectorindex</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">index_component</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">anf</span><span class="p">):</span>
        <span class="n">vectorindex</span> <span class="o">=</span> <span class="n">int2vector</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">index_component</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">))</span>
        <span class="n">canonical_vectorindex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vectorindex</span><span class="p">)</span>
        <span class="n">vectorindex</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
        <span class="n">vectorindex2_component</span><span class="p">[</span><span class="n">vectorindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">component</span> <span class="o">-</span> <span class="n">get_ct_coeff</span><span class="p">([</span><span class="n">component</span><span class="p">],</span> <span class="n">input_vars</span><span class="o">=</span><span class="n">input_vars</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">current_depth</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">canonical_vectorindex</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">currentd_vi</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">canonical_vectorindex</span><span class="p">,</span> <span class="n">current_depth</span><span class="p">):</span>
            <span class="n">currentd_vi</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">currentd_vi</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">currentd_vi</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">current_depth</span>
            <span class="n">currentd_vi</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>

            <span class="n">first_one</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">first_one</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">currentd_vi</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">d1_vi</span> <span class="o">=</span> <span class="n">int2vector</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">first_one</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">))</span>
            <span class="n">d1_vi</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>
            <span class="n">prevd_vi</span> <span class="o">=</span> <span class="n">currentd_vi</span> <span class="o">+</span> <span class="n">d1_vi</span>
            <span class="n">prevd_vi</span><span class="o">.</span><span class="n">set_immutable</span><span class="p">()</span>

            <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">d1_vi</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">prevd_vi</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">current_depth</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">vectorindex2_component</span><span class="p">[</span><span class="n">currentd_vi</span><span class="p">]</span> <span class="o">=</span> <span class="n">vectorindex2_component</span><span class="p">[</span><span class="n">d1_vi</span><span class="p">]</span> <span class="o">+</span> <span class="n">vectorindex2_component</span><span class="p">[</span><span class="n">prevd_vi</span><span class="p">]</span>

    <span class="n">equations</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">index_component</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">vectorindex2_component</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">component</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>  <span class="c1"># ct functions are not balanced</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found non-balanced component: </span><span class="si">{</span><span class="n">index_component</span><span class="si">}</span><span class="s2">-th component </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">component</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">mon2coeff</span> <span class="o">=</span> <span class="n">get_all_symbolic_coeff</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">input_vars</span><span class="p">)</span>
        <span class="n">eq_is_a_list</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">deg_component</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mon</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">for</span> <span class="n">mon</span> <span class="ow">in</span> <span class="n">mon2coeff</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">deg_component</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">deg_component</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">row_coeffs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mon2coeff</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">row_coeffs</span> <span class="ow">or</span> <span class="n">bpr</span><span class="o">.</span><span class="n">one</span><span class="p">()</span> <span class="ow">in</span> <span class="n">row_coeffs</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_coeffs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">max_deg</span><span class="p">:</span>
                <span class="c1"># row_coeffs contains unique polys (non-zero, non-one)</span>
                <span class="c1"># if there are t unique terms in row_coeffs,</span>
                <span class="c1"># then deg(OR(row_coeffs)) &gt;= t (with very high pr)</span>
                <span class="c1"># -2 is to consider dependent polys</span>
                <span class="k">continue</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">or_bits</span><span class="p">,</span> <span class="n">row_coeffs</span><span class="p">))</span> <span class="o">+</span> <span class="n">bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">deg_component</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">quad_mons</span> <span class="o">=</span> <span class="p">[</span><span class="n">mon</span> <span class="k">for</span> <span class="n">mon</span> <span class="ow">in</span> <span class="n">mon2coeff</span> <span class="k">if</span> <span class="n">mon</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">quad_mons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># in this case, only balanced class is</span>
                <span class="c1"># a(b1 + b2) + linear terms (excluded a, b1+b2, a+b1+b2)</span>
                <span class="k">continue</span>
            <span class="c1"># general case: a*x*y + a*x + b*y + c*z + d*t</span>
            <span class="c1"># 2 cases:</span>
            <span class="c1">#   a == 1, then c | d == 1</span>
            <span class="c1">#   a == 0, then b | c | d must be 1</span>
            <span class="c1"># grouped by constraint: a(c | d) + (a+1)(b | c | d) == 1</span>
            <span class="c1"># equivalently, (c | d | b*(a-1) | a*(a-1)) == 1</span>
            <span class="n">quad_mon</span> <span class="o">=</span> <span class="n">quad_mons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lin_mons</span> <span class="o">=</span> <span class="p">[</span><span class="n">mon</span> <span class="k">for</span> <span class="n">mon</span> <span class="ow">in</span> <span class="n">mon2coeff</span> <span class="k">if</span> <span class="n">mon</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">foreign_lin_mons</span> <span class="o">=</span> <span class="p">[</span><span class="n">mon</span> <span class="k">for</span> <span class="n">mon</span> <span class="ow">in</span> <span class="n">lin_mons</span> <span class="k">if</span> <span class="n">mon</span><span class="o">.</span><span class="n">variables</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">quad_mon</span><span class="o">.</span><span class="n">variables</span><span class="p">()]</span>
            <span class="n">quad_coeff</span> <span class="o">=</span> <span class="n">mon2coeff</span><span class="p">[</span><span class="n">quad_mon</span><span class="p">]</span>
            <span class="n">lin_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mon2coeff</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span> <span class="k">for</span> <span class="n">mon</span> <span class="ow">in</span> <span class="n">lin_mons</span><span class="p">]</span>
            <span class="n">foreign_lin_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mon2coeff</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span> <span class="k">for</span> <span class="n">mon</span> <span class="ow">in</span> <span class="n">foreign_lin_mons</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">lin_coeffs</span><span class="p">:</span>
                <span class="c1"># a*x*y is not balanced for any a</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found invalid equation 0 == 1 (from </span><span class="si">{</span><span class="n">index_component</span><span class="si">}</span><span class="s2">-th component </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">component</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">foreign_lin_coeffs</span><span class="p">:</span>
                    <span class="c1"># if a*x*y + a*x + b*y, then a = 0, (a|b) = 1</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="n">quad_coeff</span> <span class="o">+</span> <span class="mi">0</span><span class="p">),</span> <span class="n">bpr</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">or_bits</span><span class="p">,</span> <span class="n">lin_coeffs</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">quad_coeff</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="n">eq_is_a_list</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aux_eq1</span> <span class="o">=</span> <span class="n">quad_coeff</span> <span class="o">*</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">or_bits</span><span class="p">,</span> <span class="n">foreign_lin_coeffs</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">quad_coeff</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
                    <span class="n">aux_eq2</span> <span class="o">=</span> <span class="p">(</span><span class="n">quad_coeff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">or_bits</span><span class="p">,</span> <span class="n">lin_coeffs</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">quad_coeff</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">aux_eq1</span><span class="p">)</span> <span class="o">+</span> <span class="n">bpr</span><span class="p">(</span><span class="n">aux_eq2</span><span class="p">)</span> <span class="o">+</span> <span class="n">bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># # equivalent equation (c | d | b*(a-1) | a*(a-1)) == 1 results in the same Boolean polynomial</span>
                    <span class="c1"># non_foreign_lin_mons = [mon for mon in lin_mons if mon.variables()[0] in quad_mon.variables()]</span>
                    <span class="c1"># non_foreign_lin_coeffs = [mon2coeff[mon] * (quad_coeff + 1) for mon in non_foreign_lin_mons]</span>
                    <span class="c1"># eq = bpr(sage.all.reduce(or_bits, foreign_lin_coeffs + non_foreign_lin_coeffs)) + 1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">eq_is_a_list</span><span class="p">:</span>
            <span class="n">eq_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eq_list</span> <span class="o">=</span> <span class="n">eq</span>

        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">eq_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">eq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found invalid equation 0 == 1 (from </span><span class="si">{</span><span class="n">index_component</span><span class="si">}</span><span class="s2">-th component </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">component</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">max_deg</span><span class="p">:</span>
                <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">equations</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Adrin Ranea.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>