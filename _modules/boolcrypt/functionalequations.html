<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>boolcrypt.functionalequations &mdash; BoolCrypt 0.1.dev documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> BoolCrypt
          </a>
              <div class="version">
                0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">BoolCrypt 0.1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../boolcrypt.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BoolCrypt</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>boolcrypt.functionalequations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for boolcrypt.functionalequations</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Solve functional equations with a SAT solver.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">boolcrypt.utilities</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_smart_print</span><span class="p">,</span> <span class="n">get_anf_coeffmatrix_str</span><span class="p">,</span> <span class="n">substitute_anf</span><span class="p">,</span> <span class="n">get_time</span><span class="p">,</span>
    <span class="n">anf2matrix</span><span class="p">,</span> <span class="n">get_all_symbolic_coeff</span><span class="p">,</span> <span class="n">int2vector</span><span class="p">,</span> <span class="n">get_symbolic_alg_deg</span><span class="p">,</span>
    <span class="n">get_symbolic_anf</span><span class="p">,</span> <span class="n">concatenate_anf</span><span class="p">,</span> <span class="n">str2bp</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">sage.all</span>

<span class="kn">from</span> <span class="nn">sage.rings.polynomial.pbori.pbori</span> <span class="kn">import</span> <span class="n">BooleanPolynomialVector</span><span class="p">,</span> <span class="n">substitute_variables</span><span class="p">,</span> <span class="n">gauss_on_polys</span>
<span class="kn">from</span> <span class="nn">sage.sat.boolean_polynomials</span> <span class="kn">import</span> <span class="n">solve</span> <span class="k">as</span> <span class="n">solve_sat</span>

<span class="n">GF</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">GF</span>
<span class="n">PolynomialRing</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">PolynomialRing</span>
<span class="n">BooleanPolynomialRing</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">BooleanPolynomialRing</span>


<span class="c1"># ----------------------------------------------------</span>
<span class="c1"># auxiliary functions for solve_functional_equation()</span>
<span class="c1"># ----------------------------------------------------</span>


<span class="n">MAX_PRINTED_SIZE</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># polynomials are truncated after X chars when printed</span>


<div class="viewcode-block" id="reduce"><a class="viewcode-back" href="../../boolcrypt.functionalequations.html#boolcrypt.functionalequations.reduce">[docs]</a><span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">equations</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;gauss&quot;</span><span class="p">,</span> <span class="n">bpr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reduce a Boolean system of equations given as a list of Boolean polynomials.</span>

<span class="sd">    mode can be &quot;gauss&quot; (a BooleanPolynomialVector is returned)</span>
<span class="sd">    or &quot;groebner&quot; (a PolynomialSequence_gf2 is returned)</span>

<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import lut2anf, matrix2anf, compose_anf_fast</span>
<span class="sd">        &gt;&gt;&gt; sbox3b = [0, 1, 2, 3, 4, 6, 7, 5]  # one linear component</span>
<span class="sd">        &gt;&gt;&gt; bpr = BooleanPolynomialRing(3, &quot;x0, x1, x2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; equations = lut2anf(sbox3b)</span>
<span class="sd">        &gt;&gt;&gt; list(equations)</span>
<span class="sd">        [x0*x2 + x0 + x1*x2, x0*x2 + x1, x2]</span>
<span class="sd">        &gt;&gt;&gt; m = matrix2anf(sage.all.matrix(bpr, 3, 3, [1, 0, 1, 1, 1, 1, 1, 1, 0]))</span>
<span class="sd">        &gt;&gt;&gt; equations = compose_anf_fast(m, equations)</span>
<span class="sd">        &gt;&gt;&gt; list(equations)</span>
<span class="sd">        [x0*x2 + x0 + x1*x2 + x2, x0 + x1*x2 + x1 + x2, x0 + x1*x2 + x1]</span>
<span class="sd">        &gt;&gt;&gt; list(reduce(equations, mode=&quot;gauss&quot;, verbose=True, debug=True))</span>
<span class="sd">        reducing 3 equations with mode gauss and degrees (d,#) Counter({2: 3})</span>
<span class="sd">        system coefficient matrix:</span>
<span class="sd">        [x0*x2    x0 x1*x2    x1    x2]</span>
<span class="sd">        [-----------------------------]</span>
<span class="sd">        [    1     1     1     0     1]</span>
<span class="sd">        [    0     1     1     1     1]</span>
<span class="sd">        [    0     1     1     1     0]</span>
<span class="sd">        reduced system coefficient matrix:</span>
<span class="sd">        [x0*x2    x0 x1*x2    x1    x2]</span>
<span class="sd">        [-----------------------------]</span>
<span class="sd">        [    1     0     0     1     0]</span>
<span class="sd">        [    0     1     1     1     0]</span>
<span class="sd">        [    0     0     0     0     1]</span>
<span class="sd">        gauss-reduction obtained 3 equations with degrees (d,#) Counter({2: 2, 1: 1})</span>
<span class="sd">        [x0*x2 + x1, x0 + x1*x2 + x1, x2]</span>
<span class="sd">        &gt;&gt;&gt; reduce(equations, mode=&quot;groebner&quot;, verbose=True)  # sbox3b is a permutation</span>
<span class="sd">        reducing 3 equations with mode groebner and degrees (d,#) Counter({2: 3})</span>
<span class="sd">        groebner-reduction obtained 3 equations with degrees (d,#) Counter({1: 3})</span>
<span class="sd">        [x0, x1, x2]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gauss&quot;</span><span class="p">,</span> <span class="s2">&quot;groebner&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">equations</span>

    <span class="k">if</span> <span class="n">bpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bpr</span> <span class="o">=</span> <span class="n">equations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="o">==</span> <span class="n">bpr</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">)</span>

    <span class="n">smart_print</span> <span class="o">=</span> <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">equation_degrees</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">:</span>
            <span class="n">equation_degrees</span><span class="p">[</span><span class="n">eq</span><span class="o">.</span><span class="n">degree</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;reducing </span><span class="si">{}</span><span class="s2"> equations with mode </span><span class="si">{}</span><span class="s2"> and degrees (d,#) </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">),</span> <span class="n">mode</span><span class="p">,</span> <span class="n">equation_degrees</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
        <span class="c1"># .coefficient_matrix is too slow</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">Sequence</span><span class="p">(</span><span class="n">equations</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span><span class="o">.</span><span class="n">coefficient_matrix</span><span class="p">()</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;system coefficient matrix:&quot;</span><span class="p">)</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">bpr</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">ncols</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">list</span><span class="p">()</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
        <span class="n">aux</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="n">row_lines</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;gauss&quot;</span><span class="p">:</span>
        <span class="c1"># gauss_on_polys is sensitive to different context managers</span>
        <span class="c1"># even if they are the same Boolean polynomial ring</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">bpr</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">)</span>
        <span class="n">reduced_eqs</span> <span class="o">=</span> <span class="n">gauss_on_polys</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;groebner&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">reduced_eqs</span> <span class="o">=</span> <span class="n">bpr</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">equations</span><span class="p">))</span><span class="o">.</span><span class="n">groebner_basis</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">num_nonlinear_eqs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num_nonlinear_eqs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">equation_degrees</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_nonlinear_eqs</span> <span class="o">&gt;</span> <span class="mi">48</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;groebner raised RuntimeError </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">, retrying with gauss&quot;</span><span class="p">)</span>
                <span class="c1"># for i in range(len(equations)):  equations[i] = bpr(str(equations[i]))</span>
                <span class="n">reduced_eqs</span> <span class="o">=</span> <span class="n">gauss_on_polys</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;groebner raised RuntimeError </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">, retrying with C groebner&quot;</span><span class="p">)</span>
                <span class="c1"># old_bpr = bpr [...]  # if .change_ring, undo changes afterwards</span>
                <span class="c1"># bpr = BooleanPolynomialRing(names=[v for v in bpr.variable_names()], order=&quot;deglex&quot;)</span>
                <span class="c1"># smart_print(&quot;applying groebner with term order:&quot;, bpr.term_order())</span>
                <span class="c1"># equations = [bpr(eq) for eq in equations]</span>
                <span class="kn">from</span> <span class="nn">sage.rings.polynomial.pbori.parallel</span> <span class="kn">import</span> <span class="n">groebner_basis_first_finished</span>
                <span class="n">args1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;heuristic&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;implementation&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">}</span>
                <span class="n">args2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;heuristic&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;implementation&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">}</span>
                <span class="n">reduced_eqs</span> <span class="o">=</span> <span class="n">groebner_basis_first_finished</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">equations</span><span class="p">),</span> <span class="n">args1</span><span class="p">,</span> <span class="n">args2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid mode&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
        <span class="c1"># .coefficient_matrix is too slow</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">Sequence</span><span class="p">(</span><span class="n">reduced_eqs</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span><span class="o">.</span><span class="n">coefficient_matrix</span><span class="p">()</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;reduced system coefficient matrix:&quot;</span><span class="p">)</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">bpr</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">ncols</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">list</span><span class="p">()</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
        <span class="n">aux</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="n">row_lines</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">equation_degrees</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">reduced_eqs</span><span class="p">:</span>
            <span class="n">equation_degrees</span><span class="p">[</span><span class="n">eq</span><span class="o">.</span><span class="n">degree</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-reduction obtained </span><span class="si">{}</span><span class="s2"> equations with degrees (d,#) </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">mode</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced_eqs</span><span class="p">),</span> <span class="n">equation_degrees</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">reduced_eqs</span></div>


<span class="k">def</span> <span class="nf">_sp</span><span class="p">(</span><span class="n">polynomial</span><span class="p">):</span>  <span class="c1"># short print</span>
    <span class="n">aux</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_PRINTED_SIZE</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;BooleanPolynomial</span><span class="si">{</span><span class="n">polynomial</span><span class="o">.</span><span class="n">variables</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># return aux[:MAX_PRINTED_SIZE] + &quot;...&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">aux</span>


<span class="k">def</span> <span class="nf">_is_fixed_var</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">bpr</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">eq</span> <span class="o">+</span> <span class="n">var</span><span class="p">)</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">var</span> <span class="o">==</span> <span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
    <span class="c1"># return var not in [bpr(v) for v in (eq + var).variables()]</span>


<span class="k">def</span> <span class="nf">_find_fix_var</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">only_linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prev_eqs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixedvar2ct</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixedvar2expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">bpr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indentation_lvl</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find one fixed variable in a Boolean equation given by a Boolean polynomial.</span>

<span class="sd">    Given an equation with Boolean variables x0 &gt; ... &gt; xi &gt; ... &gt; xn,</span>
<span class="sd">    find one fixed/dependent variable, that is, an assignment x{i} = f(x{i+1},..,xn).</span>
<span class="sd">    Among all the possible fixed variables, the biggest one is chosen.</span>
<span class="sd">    (according to the term order of the Boolean polynomial ring).</span>

<span class="sd">    Additional dictionaries can be given in fixedvar2ct and fixedvar2expr</span>
<span class="sd">    mapping variables to their constant values or their symbolic expressions.</span>

<span class="sd">    This method returns None if no fixed variable is found, otherwise</span>
<span class="sd">    a triple (x{i}, f(x{i+1},..,xn), PE, UV), where:</span>

<span class="sd">    - PE is a list of indices of prev_eqs (if not None) that are found to contain</span>
<span class="sd">      fixed variables after the found fixed variable are replaced in prev_eqs.</span>
<span class="sd">    - UV is a list containing the variables that where updated in fixedvar2expr</span>
<span class="sd">      that contained x{i} in their expressions but they were replaced by</span>
<span class="sd">      f(x{i+1},..,xn).</span>

<span class="sd">    If only_linear=True, only find linear assignments.</span>

<span class="sd">    If check=True, ensures that the found fixed variable doesn&#39;t appear</span>
<span class="sd">    in other equations or in the value/expression of other fixed variable.</span>

<span class="sd">        &gt;&gt;&gt; x, y, z, t = BooleanPolynomialRing(4, &quot;x, y, z, t&quot;).gens()</span>
<span class="sd">        &gt;&gt;&gt; _find_fix_var(x + y + z*t)</span>
<span class="sd">        (x, y + z*t, [], [])</span>
<span class="sd">        &gt;&gt;&gt; _find_fix_var(x + y + z*t, only_linear=True)</span>
<span class="sd">        &gt;&gt;&gt; other_bpr = BooleanPolynomialRing(4, &quot;t, z, y, x&quot;)</span>
<span class="sd">        &gt;&gt;&gt; _find_fix_var(other_bpr(x + y + z*t))</span>
<span class="sd">        (y, t*z + x, [], [])</span>
<span class="sd">        &gt;&gt;&gt; _find_fix_var(x + y + z*t, prev_eqs=[x, y, z, t])</span>
<span class="sd">        (x, y + z*t, [0], [])</span>
<span class="sd">        &gt;&gt;&gt; _find_fix_var(x + y + z, fixedvar2expr={t: x}, fixedvar2ct={})</span>
<span class="sd">        (x, y + z, [], [t])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">only_linear</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="n">smart_print</span> <span class="o">=</span> <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bpr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="k">assert</span> <span class="ow">not</span><span class="p">(</span><span class="n">fixedvar2ct</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fixedvar2expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span><span class="p">(</span><span class="n">fixedvar2ct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fixedvar2expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fixedvar2ct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fixedvar2ct</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fixedvar2expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fixedvar2expr</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">prev_eqs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prev_eqs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">slow_sub</span> <span class="o">=</span> <span class="n">bpr</span><span class="o">.</span><span class="n">n_variables</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">32</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">slow_sub</span><span class="p">:</span>
        <span class="n">base_ordered_replacement</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">var2index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index_var</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">()):</span>
            <span class="n">var2index</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_var</span>
            <span class="n">base_ordered_replacement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subs</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">slow_sub</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bpr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">var</span><span class="p">:</span> <span class="n">val</span><span class="p">}))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">substitute_variables</span><span class="p">(</span><span class="n">bpr</span><span class="p">,</span> <span class="n">ordered_replacement</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

    <span class="c1"># take the biggest variable (probably the pivot)</span>
    <span class="c1"># thus, the smallest vars represent free parameters</span>
    <span class="n">first_var</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">variables</span><span class="p">())):</span>
        <span class="k">if</span> <span class="n">_is_fixed_var</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">bpr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">fixedvar2ct</span> <span class="ow">or</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">fixedvar2expr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fixed variable </span><span class="si">{}</span><span class="s2"> found but already in fixed_vars </span><span class="si">{}</span><span class="s2"> | eq=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">var</span><span class="p">,</span> <span class="p">{</span><span class="o">**</span><span class="n">fixedvar2ct</span><span class="p">,</span> <span class="o">**</span><span class="n">fixedvar2expr</span><span class="p">},</span> <span class="n">eq</span><span class="p">))</span>

            <span class="n">val</span> <span class="o">=</span> <span class="n">eq</span> <span class="o">+</span> <span class="n">var</span>
            <span class="n">prev_eqs_with_fx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">updated_vars</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">*</span><span class="n">indentation_lvl</span> <span class="o">+</span> <span class="s2">&quot;found </span><span class="si">{}</span><span class="s2">fixed variable </span><span class="si">{}</span><span class="s2"> &lt;- </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">first_var</span> <span class="k">else</span> <span class="s2">&quot;non-pivot &quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">_sp</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">slow_sub</span><span class="p">:</span>
                    <span class="n">ordered_replacement</span> <span class="o">=</span> <span class="n">base_ordered_replacement</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">ordered_replacement</span><span class="p">[</span><span class="n">var2index</span><span class="p">[</span><span class="n">var</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>

                <span class="n">il</span> <span class="o">=</span> <span class="n">indentation_lvl</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">fx_var</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">fixedvar2expr</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>  <span class="c1"># list() to avoid &quot;mutated during iteration error&quot;</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">var</span> <span class="o">==</span> <span class="n">bpr</span><span class="p">(</span><span class="n">v_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="n">fixedvar2expr</span><span class="p">[</span><span class="n">fx_var</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">()):</span>
                        <span class="n">updated_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fx_var</span><span class="p">)</span>
                        <span class="n">other_val</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">fixedvar2expr</span><span class="p">[</span><span class="n">fx_var</span><span class="p">],</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">other_val</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="k">del</span> <span class="n">fixedvar2expr</span><span class="p">[</span><span class="n">fx_var</span><span class="p">]</span>
                            <span class="n">fixedvar2ct</span><span class="p">[</span><span class="n">fx_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_val</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">fixedvar2expr</span><span class="p">[</span><span class="n">fx_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_val</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">*</span><span class="n">il</span> <span class="o">+</span> <span class="s2">&quot;fixed_vars[</span><span class="si">{}</span><span class="s2">] &lt;-- </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">fx_var</span><span class="p">,</span> <span class="n">_sp</span><span class="p">(</span><span class="n">other_val</span><span class="p">)))</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prev_eqs</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">var</span> <span class="o">==</span> <span class="n">bpr</span><span class="p">(</span><span class="n">v_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="n">prev_eqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">()):</span>
                        <span class="n">prev_eqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">subs</span><span class="p">(</span><span class="n">prev_eqs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">*</span><span class="n">il</span> <span class="o">+</span> <span class="s2">&quot;prev_eqs[</span><span class="si">{}</span><span class="s2">] &lt;-- </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">i</span><span class="p">,</span> <span class="n">_sp</span><span class="p">(</span><span class="n">prev_eqs</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prev_eqs_with_fx</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">only_linear</span> <span class="ow">or</span> <span class="n">prev_eqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">_is_fixed_var</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">prev_eqs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bpr</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">prev_eqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">()):</span>
                                <span class="n">prev_eqs_with_fx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                    <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">*</span><span class="p">(</span><span class="n">il</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;prev_eqs[</span><span class="si">{}</span><span class="s2">] now contains a fixed variable&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">prev_eqs_with_fx</span><span class="p">,</span> <span class="n">updated_vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first_var</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;could not find any fixed variable in linear equation </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="find_fixed_vars"><a class="viewcode-back" href="../../boolcrypt.functionalequations.html#boolcrypt.functionalequations.find_fixed_vars">[docs]</a><span class="k">def</span> <span class="nf">find_fixed_vars</span><span class="p">(</span><span class="n">equations</span><span class="p">,</span> <span class="n">only_linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">initial_r_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repeat_with_r_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">initial_fixed_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bpr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find fixed variables in a system of equations given as a list of Boolean polynomials.</span>

<span class="sd">    Given a system with Boolean variables x0 &gt; ... &gt; xi &gt; ... &gt; xn,</span>
<span class="sd">    find fixed/dependent variables, that is, assignments x{i} = f(x{i+1},..,xn).</span>
<span class="sd">    Note that the term order of the Boolean polynomial ring</span>
<span class="sd">    affects the variables that are fixed.</span>

<span class="sd">    This method returns a pair containing an OrderedDic with the</span>
<span class="sd">    fixed variables found and a BooleanPolynomialVector with the</span>
<span class="sd">    resulting system after replacing the fixed variables by their</span>
<span class="sd">    value/expression.</span>

<span class="sd">    The parameters initial_r_mode and repeat_with_r_mode can be &quot;gauss&quot; or &quot;groebner&quot;</span>
<span class="sd">    as in reduce(). initial_r_mode is used to reduce the the given list of equations.</span>
<span class="sd">    If repeat_with_r_mode is given, this method is repeatdly called again</span>
<span class="sd">    (with initial reduction the one given by repeat_with_r_mode) until</span>
<span class="sd">    no fixed variables are found.</span>

<span class="sd">    If the optional parameter initial_fixed_vars is given with a</span>
<span class="sd">    dictionary containing initial fixed variables, this method</span>
<span class="sd">    replaces the expression of these initial fixed variables</span>
<span class="sd">    with the new fixed variables found.</span>

<span class="sd">    If only_linear=True, only find linear assignment, that is,</span>
<span class="sd">    relations x{i} = f(x{i+1},..,xn) with f of degree up to 1.</span>

<span class="sd">    If check=True, ensures that no fixed variables appears in the</span>
<span class="sd">    resulting system or in the value/expression of other fixed variable.</span>

<span class="sd">    verbose and debug determine the amount of information printed to the output.</span>
<span class="sd">    if a string is given to filename, the output is printed to that file</span>

<span class="sd">        &gt;&gt;&gt; from sage.crypto.sbox import SBox</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import lut2anf</span>
<span class="sd">        &gt;&gt;&gt; sbox3b = SBox((0, 1, 2, 3, 4, 6, 7, 5))  # one linear component</span>
<span class="sd">        &gt;&gt;&gt; list(lut2anf(list(sbox3b)))</span>
<span class="sd">        [x0*x2 + x0 + x1*x2, x0*x2 + x1, x2]</span>
<span class="sd">        &gt;&gt;&gt; bpr = BooleanPolynomialRing(6, &quot;y0, y1, y2, x0, x1, x2&quot;, order=&quot;lex&quot;)</span>
<span class="sd">        &gt;&gt;&gt; input_vars, output_vars = list(reversed(bpr.gens()[3:])), list(reversed(bpr.gens()[:3]))</span>
<span class="sd">        &gt;&gt;&gt; eqs = [bpr(f) for f in sbox3b.polynomials(X=input_vars, Y=output_vars)]</span>
<span class="sd">        &gt;&gt;&gt; eqs = reduce(eqs, mode=&quot;groebner&quot;, bpr=bpr)</span>
<span class="sd">        &gt;&gt;&gt; list(eqs)</span>
<span class="sd">        [y0 + x0*x2 + x0 + x1*x2, y1 + x0*x2 + x1, y2 + x2]</span>
<span class="sd">        &gt;&gt;&gt; fixed_vars, new_eqs = find_fixed_vars(eqs, only_linear=False,</span>
<span class="sd">        ...     verbose=True, debug=True)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        finding fixed variables in 3 equations with degrees (d, #) Counter({2: 2, 1: 1})</span>
<span class="sd">        in Boolean PolynomialRing in y0, y1, y2, x0, x1, x2 with term order Lexicographic term order</span>
<span class="sd">            eqs[2] = y2 + x2</span>
<span class="sd">                found fixed variable y2 &lt;- x2</span>
<span class="sd">            eqs[1] = y1 + x0*x2 + x1</span>
<span class="sd">                found fixed variable y1 &lt;- x0*x2 + x1</span>
<span class="sd">            eqs[0] = y0 + x0*x2 + x0 + x1*x2</span>
<span class="sd">                found fixed variable y0 &lt;- x0*x2 + x0 + x1*x2</span>
<span class="sd">        found 3 fixed variables, resulting in 0 equations</span>
<span class="sd">        &gt;&gt;&gt; fixed_vars, list(new_eqs)</span>
<span class="sd">        (OrderedDict([(y2, x2), (y1, x0*x2 + x1), (y0, x0*x2 + x0 + x1*x2)]), [])</span>
<span class="sd">        &gt;&gt;&gt; fixed_vars, new_eqs = find_fixed_vars(eqs, only_linear=True, initial_r_mode=&quot;gauss&quot;,</span>
<span class="sd">        ...     repeat_with_r_mode=&quot;gauss&quot;, verbose=True, debug=False)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        reducing 3 equations with mode gauss and degrees (d,#) Counter({2: 2, 1: 1})</span>
<span class="sd">        gauss-reduction obtained 3 equations with degrees (d,#) Counter({2: 2, 1: 1})</span>
<span class="sd">        found 1 fixed variables, resulting in 2 equations with degrees (d, #) Counter({2: 2})</span>
<span class="sd">        &gt; repeating find_fixed_vars with initial reduction_mode gauss</span>
<span class="sd">        reducing 2 equations with mode gauss and degrees (d,#) Counter({2: 2})</span>
<span class="sd">        gauss-reduction obtained 2 equations with degrees (d,#) Counter({2: 2})</span>
<span class="sd">        found 1 fixed variables, resulting in 2 equations with degrees (d, #) Counter({2: 2})</span>
<span class="sd">        &gt; last find_fixed_vars call found 0 new fixed variables and removed 0 equations</span>
<span class="sd">        &gt;&gt;&gt; fixed_vars, list(new_eqs)</span>
<span class="sd">        (OrderedDict([(y2, x2)]), [y0 + x0*x2 + x0 + x1*x2, y1 + x0*x2 + x1])</span>
<span class="sd">        &gt;&gt;&gt; x, y, z, t = BooleanPolynomialRing(names=&quot;x, y, z, t&quot;).gens()</span>
<span class="sd">        &gt;&gt;&gt; eqs = [(x*y + z + 1) * (t*z + y) + 1]</span>
<span class="sd">        &gt;&gt;&gt; fixed_vars, new_eqs = find_fixed_vars(eqs, verbose=True, debug=True)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        finding fixed variables in 1 equations with degrees (d, #) Counter({4: 1})</span>
<span class="sd">        in Boolean PolynomialRing in x, y, z, t with term order Lexicographic term order</span>
<span class="sd">            eqs[0] = x*y*z*t + x*y + y*z + y + 1</span>
<span class="sd">                adding equations from common factors</span>
<span class="sd">            eqs[1] = y + 1</span>
<span class="sd">                found fixed variable y &lt;- 1</span>
<span class="sd">            eqs[0] = x*z*t + x + z</span>
<span class="sd">        found 1 fixed variables, resulting in 1 equations with degrees (d, #) Counter({3: 1})</span>
<span class="sd">        &gt;&gt;&gt; fixed_vars, list(new_eqs)</span>
<span class="sd">        (OrderedDict([(y, 1)]), [x*z*t + x + z])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smart_print</span> <span class="o">=</span> <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">initial_fixed_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_fixed_vars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">equations</span>

    <span class="k">if</span> <span class="n">initial_fixed_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">var2ct</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">var2expr</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initial_fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">var2ct</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var2expr</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">var2ct</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">var2expr</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">bpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bpr</span> <span class="o">=</span> <span class="n">equations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="o">==</span> <span class="n">bpr</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">)</span>
    <span class="n">bpr_gens_dict</span> <span class="o">=</span> <span class="n">bpr</span><span class="o">.</span><span class="n">gens_dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">initial_r_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">equations</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">equations</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">initial_r_mode</span><span class="p">,</span> <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">initial_r_mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">equation_degrees</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">:</span>
                <span class="n">equation_degrees</span><span class="p">[</span><span class="n">eq</span><span class="o">.</span><span class="n">degree</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">aux</span> <span class="o">+=</span> <span class="s2">&quot;in </span><span class="si">{}</span><span class="s2"> equations with degrees (d, #) </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">),</span> <span class="n">equation_degrees</span><span class="p">)</span>
            <span class="n">aux</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">debug</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">aux</span> <span class="o">+=</span> <span class="s2">&quot;in </span><span class="si">{}</span><span class="s2"> with term order </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bpr</span><span class="p">,</span> <span class="n">bpr</span><span class="o">.</span><span class="n">term_order</span><span class="p">())</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;finding fixed variables </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aux</span><span class="p">))</span>

    <span class="n">ordered_replacement</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">var2index_ordered_replacement</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index_var</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">()):</span>
        <span class="n">var2index_ordered_replacement</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_var</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">var2ct</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">var2ct</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">var2expr</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">var2expr</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">var</span>
        <span class="n">ordered_replacement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">only_linear</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">var2expr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">initial_r_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
            <span class="nb">all</span><span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">TermOrder</span><span class="p">(</span><span class="s1">&#39;deglex&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">bpr</span><span class="o">.</span><span class="n">term_order</span><span class="p">()</span><span class="o">.</span><span class="n">blocks</span><span class="p">()):</span>
        <span class="c1"># in this case, the first linear equations are not checked</span>
        <span class="n">check_find_fix_var</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">check_find_fix_var</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># backward substitution with an upper triangular matrix (starting with the last equation)</span>
    <span class="n">equations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span>  <span class="c1"># need to be a list to use pop()</span>
    <span class="n">new_equations</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># need to be a list to remove elements</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">index_eq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">check_find_fix_var</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">equations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">check_find_fix_var</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">eq</span> <span class="o">=</span> <span class="n">equations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># only need to sub previous equations and fixed_vars</span>
        <span class="n">new_eq</span> <span class="o">=</span> <span class="n">substitute_variables</span><span class="p">(</span><span class="n">bpr</span><span class="p">,</span> <span class="n">ordered_replacement</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span>
        <span class="c1"># new_eq = bpr(eq.subs(var2ct).subs(var2expr))</span>

        <span class="k">if</span> <span class="n">new_eq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">new_eq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found 0 == 1 from eqs[</span><span class="si">{</span><span class="n">index_eq</span><span class="si">}</span><span class="s2">] = (</span><span class="si">{</span><span class="n">eq</span><span class="si">}</span><span class="s2">).subs(</span><span class="si">{</span><span class="n">var2ct</span><span class="p">,</span> <span class="n">var2expr</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_eq</span> <span class="o">!=</span> <span class="n">eq</span><span class="p">:</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="s2">&quot; | before substitution </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_sp</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">eqs[</span><span class="si">{}</span><span class="s2">] = </span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index_eq</span><span class="p">,</span> <span class="n">_sp</span><span class="p">(</span><span class="n">new_eq</span><span class="p">),</span> <span class="n">aux</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">_find_fix_var</span><span class="p">(</span><span class="n">new_eq</span><span class="p">,</span> <span class="n">only_linear</span><span class="o">=</span><span class="n">only_linear</span><span class="p">,</span> <span class="n">prev_eqs</span><span class="o">=</span><span class="n">new_equations</span><span class="p">,</span>
                               <span class="n">fixedvar2ct</span><span class="o">=</span><span class="n">var2ct</span><span class="p">,</span> <span class="n">fixedvar2expr</span><span class="o">=</span><span class="n">var2expr</span><span class="p">,</span> <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check_find_fix_var</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">indentation_lvl</span><span class="o">=</span><span class="mi">2</span> <span class="k">if</span> <span class="n">debug</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">prev_eqs_with_fv</span><span class="p">,</span> <span class="n">updated_vars</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">var2ct</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="n">ordered_replacement</span><span class="p">[</span><span class="n">var2index_ordered_replacement</span><span class="p">[</span><span class="n">var</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var2expr</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="n">ordered_replacement</span><span class="p">[</span><span class="n">var2index_ordered_replacement</span><span class="p">[</span><span class="n">var</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">if</span> <span class="n">prev_eqs_with_fv</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2">checking new_equations</span><span class="si">{}</span><span class="s2"> before checking eq[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">prev_eqs_with_fv</span><span class="p">,</span> <span class="n">index_eq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">index_eq_w_fv</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">prev_eqs_with_fv</span><span class="p">):</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="n">new_equations</span><span class="p">[</span><span class="n">index_eq_w_fv</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">new_equations</span><span class="p">[</span><span class="n">index_eq_w_fv</span><span class="p">]</span>
                    <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u_v</span> <span class="ow">in</span> <span class="n">updated_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2">updating ordered_replacement with updated_vars&quot;</span><span class="p">,</span> <span class="n">updated_vars</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">u_v</span> <span class="ow">in</span> <span class="n">var2ct</span><span class="p">:</span>
                    <span class="n">ordered_replacement</span><span class="p">[</span><span class="n">var2index_ordered_replacement</span><span class="p">[</span><span class="n">u_v</span><span class="p">]]</span> <span class="o">=</span> <span class="n">var2ct</span><span class="p">[</span><span class="n">u_v</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ordered_replacement</span><span class="p">[</span><span class="n">var2index_ordered_replacement</span><span class="p">[</span><span class="n">u_v</span><span class="p">]]</span> <span class="o">=</span> <span class="n">var2expr</span><span class="p">[</span><span class="n">u_v</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">new_eq</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">new_eq</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_equations</span><span class="p">:</span>
                    <span class="n">new_equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_eq</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># e.g., if x1*x2 + 1 == 0, add the equations x1==1, x2==1</span>
                <span class="k">if</span> <span class="n">new_eq</span><span class="o">.</span><span class="n">constant_coefficient</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sr_expr</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">symbolic_expression</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">new_eq</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sr_expr</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">symbolic_expression</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">new_eq</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">sr_expr</span> <span class="o">=</span> <span class="n">sr_expr</span><span class="o">.</span><span class="n">collect_common_factors</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">sr_expr</span><span class="o">.</span><span class="n">operator</span><span class="p">()</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;mul&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2">adding equations from common factors&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">sr_expr</span><span class="o">.</span><span class="n">collect_common_factors</span><span class="p">()</span><span class="o">.</span><span class="n">operands</span><span class="p">():</span>
                        <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">str2bp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; + 1&quot;</span><span class="p">,</span> <span class="n">bpr_gens_dict</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">new_eq</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_equations</span><span class="p">:</span>
                        <span class="n">new_equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_eq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">num_zero_eqs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">new_equations</span><span class="p">:</span>
            <span class="n">equation_degrees</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">new_equations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">eq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">num_zero_eqs</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="n">deg</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
                <span class="n">equation_degrees</span><span class="p">[</span><span class="n">deg</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">aux</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; with degrees (d, #) </span><span class="si">{</span><span class="n">equation_degrees</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;found </span><span class="si">{}</span><span class="s2"> fixed variables, resulting in </span><span class="si">{}</span><span class="s2"> equations</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">var2expr</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">var2ct</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_equations</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_zero_eqs</span><span class="p">,</span> <span class="n">aux</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">repeat_with_r_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&gt; repeating find_fixed_vars with initial reduction_mode </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">repeat_with_r_mode</span><span class="p">))</span>
            <span class="n">other_coeff2expr</span><span class="p">,</span> <span class="n">other_new_equations</span> <span class="o">=</span> <span class="n">find_fixed_vars</span><span class="p">(</span>
                <span class="n">new_equations</span><span class="p">,</span> <span class="n">only_linear</span><span class="o">=</span><span class="n">only_linear</span><span class="p">,</span> <span class="n">initial_r_mode</span><span class="o">=</span><span class="n">repeat_with_r_mode</span><span class="p">,</span> <span class="n">repeat_with_r_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">initial_fixed_vars</span><span class="o">=</span><span class="n">var2expr</span><span class="p">,</span> <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_coeff2expr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var2expr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&gt; last find_fixed_vars call found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">other_coeff2expr</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">var2expr</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; new fixed variables and removed </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_equations</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_new_equations</span><span class="p">)</span><span class="si">}</span><span class="s2"> equations&quot;</span><span class="p">)</span>
            <span class="n">to_break</span> <span class="o">=</span> <span class="n">other_coeff2expr</span> <span class="o">==</span> <span class="n">var2expr</span>
            <span class="n">var2expr</span> <span class="o">=</span> <span class="n">other_coeff2expr</span>
            <span class="n">new_equations</span> <span class="o">=</span> <span class="n">other_new_equations</span>
            <span class="k">if</span> <span class="n">to_break</span><span class="p">:</span>
                <span class="c1"># even if other_coeff2expr == coeff2expr, other_new_equations &lt; new_equations</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># always return a BooleanPolynomialVector for consistency</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">new_eq</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">new_equations</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_eq</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">aux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_eq</span><span class="p">)</span>
        <span class="n">new_equations</span> <span class="o">=</span> <span class="n">aux</span>

    <span class="n">fixed_vars</span> <span class="o">=</span> <span class="n">var2ct</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">fixed_vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">var2expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">prev_var</span> <span class="ow">in</span> <span class="n">fixed_vars</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fixed_vars</span><span class="p">[</span><span class="n">prev_var</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fixed_vars</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fixed variable </span><span class="si">{}</span><span class="s2"> in fixed_vars[</span><span class="si">{}</span><span class="s2">] = </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">v</span><span class="p">,</span> <span class="n">prev_var</span><span class="p">,</span> <span class="n">fixed_vars</span><span class="p">[</span><span class="n">prev_var</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_equations</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_equations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="n">new_equations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fixed_vars</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fixed variable </span><span class="si">{}</span><span class="s2"> in new_equations[</span><span class="si">{}</span><span class="s2">] = </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">eq</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">only_linear</span> <span class="ow">or</span> <span class="n">eq</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_fixed_var</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">bpr</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;undetected fixed var </span><span class="si">{}</span><span class="s2"> in new_equations[</span><span class="si">{}</span><span class="s2">] = </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">eq</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fixed_vars</span><span class="p">,</span> <span class="n">new_equations</span></div>

<span class="c1"># ----------------------------------------------------</span>
<span class="c1"># ----------------------------------------------------</span>
<span class="c1"># ----------------------------------------------------</span>


<div class="viewcode-block" id="solve_functional_equation"><a class="viewcode-back" href="../../boolcrypt.functionalequations.html#boolcrypt.functionalequations.solve_functional_equation">[docs]</a><span class="k">def</span> <span class="nf">solve_functional_equation</span><span class="p">(</span>
    <span class="c1"># mandatory args</span>
    <span class="n">lhs_anfs</span><span class="p">,</span> <span class="n">rhs_anfs</span><span class="p">,</span>
    <span class="n">lhs_input_vars</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">,</span>
    <span class="n">num_sat_solutions</span><span class="p">,</span>
    <span class="n">return_mode</span><span class="p">,</span>
    <span class="c1"># alternative modes</span>
    <span class="n">find_redundant_equations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1"># solving args</span>
    <span class="n">initial_equations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">initial_fixed_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">reduction_mode</span><span class="o">=</span><span class="s2">&quot;gauss&quot;</span><span class="p">,</span>
    <span class="n">only_linear_fixed_vars</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">find_linear_combinations_in_solutions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="c1"># optimization args</span>
    <span class="n">threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">num_sols_per_base_sol_to_check</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">bpr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ignore_varnames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ignore_initial_parsing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">check_find_fixed_vars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># printing args</span>
    <span class="n">return_total_num_solutions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span>
    <span class="c1"># print_common_nonlinear_vars=False,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve a functional equation F = G given by list of Boolean polynomials.</span>

<span class="sd">    This methods requires the CryptoMiniSat package to be installed in SageMath.</span>

<span class="sd">    The left hand side F(x) = ...F1(F0(x)) is given a list of ANF [F0, F1, ...],</span>
<span class="sd">    where some of them can be symbolic ANFs.</span>
<span class="sd">    The right hand side G(x) = ...G1(G0(x)) can be given similarly [G0, G1, ...],</span>
<span class="sd">    or it can be given a list of integers [d0, d1, ..., dd].</span>
<span class="sd">    In the latter case, the problem changes to find F that only have</span>
<span class="sd">    monomials with degrees [d0, d1, ..., dd].</span>
<span class="sd">    At least one of the ANFs Fi or Gj should be a symbolic anf.</span>

<span class="sd">    lhs_input_vars is a list of the inputs vars (a list of Boolean variables</span>
<span class="sd">    or strings) for each ANF in F (similarly for rhs_input_vars and G).</span>
<span class="sd">    If rhs_anfs is given as a list of integers, the value of rhs_input_vars</span>
<span class="sd">    is ignored.</span>

<span class="sd">    num_sat_solutions is the number of solutions to be found by the SAT solver.</span>
<span class="sd">    To find all solutions, use None or sage.all.infinity.</span>
<span class="sd">    Note that number of actual solutions can be higher than the</span>
<span class="sd">    number of solutions internally found by the SAT solver,</span>
<span class="sd">    as fixed variables and free variables are not passed to the SAT solver.</span>

<span class="sd">    If the system of equations is found to be inconsistent (unsatisfiable),</span>
<span class="sd">    a ValueError exception is raised.</span>

<span class="sd">    If return_mode=&quot;list_anfs&quot;, return a list of solutions [s0, s1, ...],</span>
<span class="sd">    where each solution si = [siF, siG] is a pair containing the list of</span>
<span class="sd">    non-symbolic ANFs of the left and right side, that is,</span>
<span class="sd">    [siF, siG] = [[siF0, siF1, ...], [siG0, siG1, ...]].</span>

<span class="sd">    If return_mode=&quot;list_coeffs&quot;, return a tuple containing</span>
<span class="sd">    the list of solutions [s0, s1, ...], where each si is a list</span>
<span class="sd">    containing the ANF coefficients of [siF, siG], and a list</span>
<span class="sd">    with the free variables.</span>

<span class="sd">    If return_mode=&quot;symbolic_anf&quot;, the solutions are given symbolically</span>
<span class="sd">    that is, a 4-tuple is returned (symF, symG, eqs, num_sols).</span>
<span class="sd">    For symF = [symF0, symF1, ...], symFi is the symbolic ANF of Fi,</span>
<span class="sd">    where each coefficient is substituted with the fixed variables found</span>
<span class="sd">    (and similar for symG and symGi).</span>
<span class="sd">    The list eqs contain the equations that the symbolic coefficients</span>
<span class="sd">    satisfy that could not be reduced more.</span>
<span class="sd">    The number num_sols represents the total number of solutions found.</span>

<span class="sd">    If return_mode=&quot;symbolic_coeffs&quot;, the solutions are given symbolically</span>
<span class="sd">    but a 3-tuple is returned (fvs, eqs, num_sols).</span>
<span class="sd">    fvs is a dictionary of fixed variables mapping the variables</span>
<span class="sd">    to their symbolic or constant values,</span>
<span class="sd">    and (eqs, num_sols) is similar as in return_mode=&quot;symbolic_anf&quot;.</span>

<span class="sd">    If return_mode=raw_equations, return the list of equations associated</span>
<span class="sd">    to the functional problem before finding fixed variables and before</span>
<span class="sd">    calling the SAT solver.</span>

<span class="sd">    If return_mode=&quot;lincomb_solutions&quot;, it returns the linear combinations</span>
<span class="sd">    among the solutions obtained from the SAT solver (see below the explanation</span>
<span class="sd">    regarding find_linear_combinations_in_solutions).</span>

<span class="sd">    A Boolean polynomial ring bpr can be given to determine the</span>
<span class="sd">    term order. Otherwise, lexicographic order will be used</span>
<span class="sd">    (x0 &gt; x1 &gt; ..., F0 &gt; F1 &gt; ... &gt; G0 &gt; G1 &gt; ... ).</span>

<span class="sd">    A list of equations can be given in find_redundant_equations.</span>
<span class="sd">    In that case, instead of solving the functional equation,</span>
<span class="sd">    it is returned the list of equations that are satisfied by all solutions.</span>

<span class="sd">    A list of fixed variables can be given in initial_fixed_vars</span>
<span class="sd">    as a dictionary mapping variables to their constant or symbolic values.</span>

<span class="sd">    A list of Boolean equations (or strings) can be given in initial_equations</span>
<span class="sd">    which will be added as extra constraints to the funcional equation.</span>

<span class="sd">    reduction_mode is the type of reduction (None, &quot;gauss&quot; or &quot;groebner&quot;)</span>
<span class="sd">    to apply before the SAT solver.</span>

<span class="sd">    Before the SAT solver is called, fixed variables are searched</span>
<span class="sd">    in the equations. If only_linear_fixed_vars is True, only</span>
<span class="sd">    linear assignments are searched, that is,</span>
<span class="sd">    relations x{i} = f(x{i+1},..,xn) with f of degree up to 1.</span>

<span class="sd">    find_linear_combinations_in_solutions determines whether to search</span>
<span class="sd">    for linear combinations among the solutions obtained from the SAT solver.</span>
<span class="sd">    The obtained linear combinations are used to simplify</span>
<span class="sd">    the system of equations and the list of fixed variables.</span>
<span class="sd">    If the number of obtained SAT solutions is less than the given</span>
<span class="sd">    num_sat_solutions, find_linear_combinations_in_solutions is</span>
<span class="sd">    automatically enabled.</span>

<span class="sd">    If return_total_num_solutions is True, append to the output</span>
<span class="sd">    the number of total solutions (taking into account the free variables).</span>

<span class="sd">    If ignore_initial_parsing is True, then initial_fixed_vars is not used to replace</span>
<span class="sd">    variables in the list of ANF or in the list of initial equations (in the first pass),</span>
<span class="sd">    and other checks regarding the BooleanPolynomialRing are ignored.</span>
<span class="sd">    The default value of ignore_initial_parsing (False) is recommended.</span>

<span class="sd">    If check_find_fixed_vars is True, internal calls to find_fixed_vars</span>
<span class="sd">    are done with check=True (see find_fixed_vars).</span>

<span class="sd">    A list of variables (strings or Boolean variables) can be given in</span>
<span class="sd">    ignore_varnames, which won&#39;t be included in the solutions and will</span>
<span class="sd">    be set to 0 if they are free variables.</span>

<span class="sd">    num_sols_per_base_sol_to_check determines the number of solutions</span>
<span class="sd">    per base solution that are checked, that is, that are given</span>
<span class="sd">    to the verification test F = G where F and G are substituted with</span>
<span class="sd">    the exact non-symbolic coefficients of the solution.</span>

<span class="sd">    threads determines the number of threads for the SAT solver to use.</span>

<span class="sd">    verbose and debug (True or False values) determine</span>
<span class="sd">    the amount of information printed to the output.</span>
<span class="sd">    if a string is given to filename, the output is printed to that file</span>

<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import lut2anf, invert_lut</span>
<span class="sd">        &gt;&gt;&gt; # example 1: finding the inverse of F0 by solving F1(F0) = Identity</span>
<span class="sd">        &gt;&gt;&gt; f0 = lut2anf((0, 1, 2, 3, 4, 6, 7, 5))</span>
<span class="sd">        &gt;&gt;&gt; f1 = get_symbolic_anf(2, 3, 3)</span>
<span class="sd">        &gt;&gt;&gt; g0 = lut2anf(list(range(2**3)))  # identity</span>
<span class="sd">        &gt;&gt;&gt; input_vars = [&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;]</span>
<span class="sd">        &gt;&gt;&gt; list_anfs = solve_functional_equation([f0, f1], [g0], [input_vars, input_vars], [input_vars],</span>
<span class="sd">        ...     num_sat_solutions=1, return_mode=&quot;list_anfs&quot;, verbose=True)  # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS</span>
<span class="sd">        solving the functional equation F1(F0) = G0</span>
<span class="sd">        - F1:</span>
<span class="sd">        [ x0*x1  x0*x2  x1*x2|    x0     x1     x2|     1]</span>
<span class="sd">        [--------------------+--------------------+------]</span>
<span class="sd">        [a0_0_1 a0_0_2 a0_1_2|  a0_0   a0_1   a0_2|    a0]</span>
<span class="sd">        [a1_0_1 a1_0_2 a1_1_2|  a1_0   a1_1   a1_2|    a1]</span>
<span class="sd">        [a2_0_1 a2_0_2 a2_1_2|  a2_0   a2_1   a2_2|    a2]</span>
<span class="sd">        - F0:</span>
<span class="sd">        [x0*x2 x1*x2|   x0    x1    x2]</span>
<span class="sd">        [-----------+-----------------]</span>
<span class="sd">        [    1     1|    1     0     0]</span>
<span class="sd">        [    1     0|    0     1     0]</span>
<span class="sd">        [    0     0|    0     0     1]</span>
<span class="sd">        - G0:</span>
<span class="sd">        [x0 x1 x2]</span>
<span class="sd">        [--------]</span>
<span class="sd">        [ 1  0  0]</span>
<span class="sd">        [ 0  1  0]</span>
<span class="sd">        [ 0  0  1]</span>
<span class="sd">        number of input variables: 4</span>
<span class="sd">        number of symbolic coefficients: 21</span>
<span class="sd">        ... | computing F and G</span>
<span class="sd">        ... | getting equations from F + G = 0</span>
<span class="sd">        ... | finding fixed and free variables and reducing system</span>
<span class="sd">        reducing 21 equations with mode gauss and degrees (d,#) Counter({1: 21})</span>
<span class="sd">        gauss-reduction obtained 21 equations with degrees (d,#) Counter({1: 21})</span>
<span class="sd">        found 21 fixed variables, resulting in 0 equations</span>
<span class="sd">        &gt; repeating find_fixed_vars with initial reduction_mode gauss</span>
<span class="sd">        &gt; last find_fixed_vars call found 0 new fixed variables and removed 0 equations</span>
<span class="sd">        fixed variables (21): [(&#39;a2&#39;, 0), (&#39;a2_2&#39;, 1), (&#39;a2_1&#39;, 0), (&#39;a2_0&#39;, 0), (&#39;a2_1_2&#39;, 0), (&#39;a2_0_2&#39;, 0),</span>
<span class="sd">        (&#39;a2_0_1&#39;, 0), (&#39;a1&#39;, 0), (&#39;a1_2&#39;, 0), (&#39;a1_1&#39;, 1), (&#39;a1_0&#39;, 0), (&#39;a1_1_2&#39;, 1), (&#39;a1_0_2&#39;, 1),</span>
<span class="sd">        (&#39;a1_0_1&#39;, 0), (&#39;a0&#39;, 0), (&#39;a0_2&#39;, 0), (&#39;a0_1&#39;, 0), (&#39;a0_0&#39;, 1), (&#39;a0_1_2&#39;, 1), (&#39;a0_0_2&#39;, 0), (&#39;a0_0_1&#39;, 0)]</span>
<span class="sd">        free variables (0): []</span>
<span class="sd">        ... | ignoring SAT solving step</span>
<span class="sd">        total number of solutions: 1</span>
<span class="sd">        ... | returning outputs with mode=&#39;list_anfs&#39;</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(list_anfs[0][0][1], input_vars=input_vars)  # f1</span>
<span class="sd">        [x0*x2 x1*x2|   x0    x1    x2]</span>
<span class="sd">        [-----------+-----------------]</span>
<span class="sd">        [    0     1|    1     0     0]</span>
<span class="sd">        [    1     1|    0     1     0]</span>
<span class="sd">        [    0     0|    0     0     1]</span>
<span class="sd">        &gt;&gt;&gt; # same example, but now f1 is given and f0 is symbolic</span>
<span class="sd">        &gt;&gt;&gt; f0 = get_symbolic_anf(2, 3, 3)</span>
<span class="sd">        &gt;&gt;&gt; f1 = lut2anf(invert_lut([0, 1, 2, 3, 4, 6, 7, 5]))</span>
<span class="sd">        &gt;&gt;&gt; list_anfs = solve_functional_equation([f0, f1], [g0], [input_vars, input_vars], [input_vars],</span>
<span class="sd">        ...     num_sat_solutions=1, return_mode=&quot;list_anfs&quot;)</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(list_anfs[0][0][0], input_vars=input_vars)  # f0</span>
<span class="sd">        [x0*x2 x1*x2|   x0    x1    x2]</span>
<span class="sd">        [-----------+-----------------]</span>
<span class="sd">        [    1     1|    1     0     0]</span>
<span class="sd">        [    1     0|    0     1     0]</span>
<span class="sd">        [    0     0|    0     0     1]</span>
<span class="sd">        &gt;&gt;&gt; # example 2: finding a 2-bit linear permutation F0 by solving [(y,x), F0] = [1, 1]</span>
<span class="sd">        &gt;&gt;&gt; #            with the extra condition a0_0 + 0</span>
<span class="sd">        &gt;&gt;&gt; f0 = get_symbolic_anf(1, 2, 2, ct_terms=False)</span>
<span class="sd">        &gt;&gt;&gt; f1 = lut2anf([0, 2, 1, 3])  # (x, y) to (y, x)</span>
<span class="sd">        &gt;&gt;&gt; input_vars = [&quot;x0&quot;, &quot;x1&quot;]</span>
<span class="sd">        &gt;&gt;&gt; init_eq = [&quot;a0_0&quot;, anf2matrix(f0, input_vars).determinant() + 1]</span>
<span class="sd">        &gt;&gt;&gt; result = solve_functional_equation([f0, f1], [1, 1], [input_vars, input_vars], None,</span>
<span class="sd">        ...     num_sat_solutions=None, return_mode=&quot;symbolic_anf&quot;, initial_equations=init_eq, reduction_mode=None,</span>
<span class="sd">        ...     verbose=True, debug=True)  # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS</span>
<span class="sd">        solving the functional equation F1(F0) = degrees([1, 1])</span>
<span class="sd">        - F1:</span>
<span class="sd">        [x0 x1]</span>
<span class="sd">        [-----]</span>
<span class="sd">        [ 0  1]</span>
<span class="sd">        [ 1  0]</span>
<span class="sd">        - F0:</span>
<span class="sd">        [  x0   x1]</span>
<span class="sd">        [---------]</span>
<span class="sd">        [a0_0 a0_1]</span>
<span class="sd">        [a1_0 a1_1]</span>
<span class="sd">        input variables (2): [&#39;x0&#39;, &#39;x1&#39;]</span>
<span class="sd">        symbolic coefficients (4): [&#39;a0_0&#39;, &#39;a0_1&#39;, &#39;a1_0&#39;, &#39;a1_1&#39;]</span>
<span class="sd">        Boolean PolynomialRing in x0, x1, a0_0, a0_1, a1_0, a1_1</span>
<span class="sd">        initial equations (2):</span>
<span class="sd">    	    a0_0</span>
<span class="sd">    	    a0_0*a1_1 + a0_1*a1_0 + 1</span>
<span class="sd">        ... | computing F and G</span>
<span class="sd">        - F (after composition):</span>
<span class="sd">        [  x0   x1]</span>
<span class="sd">        [---------]</span>
<span class="sd">        [a1_0 a1_1]</span>
<span class="sd">        [a0_0 a0_1]</span>
<span class="sd">        ... | getting equations from F + G = 0</span>
<span class="sd">        no equation added from F + G = 0</span>
<span class="sd">        ... | finding fixed and free variables</span>
<span class="sd">        finding fixed variables in 2 equations with degrees (d, #) Counter({1: 1, 2: 1})</span>
<span class="sd">        in Boolean PolynomialRing in x0, x1, a0_0, a0_1, a1_0, a1_1 with term order Lexicographic term order</span>
<span class="sd">            eqs[1] = a0_0*a1_1 + a0_1*a1_0 + 1</span>
<span class="sd">            eqs[0] = a0_0</span>
<span class="sd">                found fixed variable a0_0 &lt;- 0</span>
<span class="sd">                    prev_eqs[0] &lt;-- a0_1*a1_0 + 1</span>
<span class="sd">        found 1 fixed variables, resulting in 1 equations with degrees (d, #) Counter({2: 1})</span>
<span class="sd">        fixed variables (1): [(&#39;a0_0&#39;, 0)]</span>
<span class="sd">        free variables (1): [a1_1]</span>
<span class="sd">        ... | solving 1 equations with 2 variables using SAT solver</span>
<span class="sd">        solver options: num_sat_solutions=+Infinity, threads=1</span>
<span class="sd">        system variables: [a1_0, a0_1]</span>
<span class="sd">        ... | parsing 1 SAT solutions found (total number of solutions 2 = 2^{1})</span>
<span class="sd">        SAT solutions:</span>
<span class="sd">            {a0_1: 1, a1_0: 1}</span>
<span class="sd">        Base solution 1 out of 1, checking full solution 1 out of 1:</span>
<span class="sd">         - sat solution                          : {a0_1: 1, a1_0: 1}</span>
<span class="sd">         - sat solution + fixed vars             : OrderedDict([(a0_1, 1), (a1_0, 1), (a0_0, 0)])</span>
<span class="sd">         - sat solution + fixed vars + free vars : {a0_1: 1, a1_0: 1, a0_0: 0, a1_1: 0}</span>
<span class="sd">         - F:</span>
<span class="sd">        [x0 x1]</span>
<span class="sd">        [-----]</span>
<span class="sd">        [ 1  0]</span>
<span class="sd">        [ 0  1]</span>
<span class="sd">        ... | finding linear combinations of variables among the SAT solutions</span>
<span class="sd">        linear combinations (2): [&#39;a1_0 + 1&#39;, &#39;a0_1 + 1&#39;]</span>
<span class="sd">        linear combinations (matrix form)</span>
<span class="sd">        [a1_0 a0_1    1]</span>
<span class="sd">        [--------------]</span>
<span class="sd">        [   1    0    1]</span>
<span class="sd">        [   0    1    1]</span>
<span class="sd">        ... | reducing system with the linear combinations obtained</span>
<span class="sd">        finding fixed variables in 3 equations with degrees (d, #) Counter({1: 2, 2: 1})</span>
<span class="sd">        in Boolean PolynomialRing in x0, x1, a0_0, a0_1, a1_0, a1_1 with term order Lexicographic term order</span>
<span class="sd">            eqs[2] = a0_1 + 1</span>
<span class="sd">                found fixed variable a0_1 &lt;- 1</span>
<span class="sd">            eqs[1] = a1_0 + 1</span>
<span class="sd">                found fixed variable a1_0 &lt;- 1</span>
<span class="sd">        found 2 fixed variables, resulting in 0 equations</span>
<span class="sd">        fixed variables (3): [(&#39;a0_0&#39;, 0), (&#39;a0_1&#39;, 1), (&#39;a1_0&#39;, 1)]</span>
<span class="sd">        number of system variables changed to 0</span>
<span class="sd">        system variables (0): []</span>
<span class="sd">        number of equations changed to 0</span>
<span class="sd">        ... | returning outputs with mode=&#39;symbolic_anf&#39;</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(result[0][0][0], input_vars=input_vars)  # f0</span>
<span class="sd">        [  x0   x1]</span>
<span class="sd">        [---------]</span>
<span class="sd">        [   0    1]</span>
<span class="sd">        [   1 a1_1]</span>
<span class="sd">        &gt;&gt;&gt; list(result[1])  # equations</span>
<span class="sd">        []</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smart_print</span> <span class="o">=</span> <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">assert</span> <span class="n">return_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;list_anfs&quot;</span><span class="p">,</span> <span class="s2">&quot;list_coeffs&quot;</span><span class="p">,</span> <span class="s2">&quot;symbolic_anf&quot;</span><span class="p">,</span> <span class="s2">&quot;symbolic_coeffs&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;raw_equations&quot;</span><span class="p">,</span> <span class="s2">&quot;lincomb_solutions&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">reduction_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;gauss&quot;</span><span class="p">,</span> <span class="s2">&quot;groebner&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">rhs_anfs</span><span class="p">):</span>
        <span class="n">rhs_degrees</span> <span class="o">=</span> <span class="n">rhs_anfs</span>
        <span class="n">rhs_anfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rhs_input_vars</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rhs_degrees</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_anfs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_input_vars</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_anfs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_input_vars</span><span class="p">),</span> \
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">lhs_anfs</span><span class="p">)</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">lhs_input_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">rhs_anfs</span><span class="p">)</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">rhs_input_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="n">initial_equations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_equations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">initial_fixed_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_fixed_vars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">ignore_varnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ignore_varnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ignore_varnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ignore_varnames</span><span class="p">)</span>

    <span class="c1"># 1. Find common Boolean polynomial ring</span>

    <span class="k">if</span> <span class="n">bpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># (x0 &gt; x1 &gt; ..., F0 &gt; F1 &gt; ... &gt; G0 &gt; G1 &gt; ... &gt; initial equations)</span>
        <span class="n">all_varnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">anf_input_vars</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">lhs_input_vars</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">anf_input_vars</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_varnames</span><span class="p">:</span>
                    <span class="n">all_varnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
        <span class="n">num_total_input_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_varnames</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">lhs_anfs</span><span class="p">,</span> <span class="n">rhs_anfs</span><span class="p">):</span>
            <span class="n">aux_anf_bpr</span> <span class="o">=</span> <span class="n">anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">aux_anf_bpr</span> <span class="o">==</span> <span class="n">component</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">anf</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">varname</span> <span class="ow">in</span> <span class="n">aux_anf_bpr</span><span class="o">.</span><span class="n">variable_names</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_varnames</span><span class="p">:</span>
                    <span class="n">all_varnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initial_fixed_vars</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">symbolic_expression</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_varnames</span><span class="p">:</span>
                    <span class="n">all_varnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">initial_equations</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">symbolic_expression</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_varnames</span><span class="p">:</span>
                    <span class="n">all_varnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">find_redundant_equations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">find_redundant_equations</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">symbolic_expression</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_varnames</span><span class="p">:</span>
                        <span class="n">all_varnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">only_linear_fixed_vars</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;deglex&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;lex&quot;</span>
        <span class="n">bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_varnames</span><span class="p">),</span> <span class="n">all_varnames</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="n">num_total_symbolic_coeffs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_varnames</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_total_input_vars</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_varnames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">anf_input_vars</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">lhs_input_vars</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">anf_input_vars</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
                <span class="n">input_varnames</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
        <span class="n">num_total_input_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_varnames</span><span class="p">)</span>
        <span class="n">num_total_symbolic_coeffs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">())</span> <span class="o">-</span> <span class="n">num_total_input_vars</span>
        <span class="n">all_varnames</span> <span class="o">=</span> <span class="n">bpr</span><span class="o">.</span><span class="n">variable_names</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_initial_parsing</span><span class="p">:</span>
        <span class="n">aux_ifv</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initial_fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">aux_ifv</span><span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">initial_fixed_vars</span> <span class="o">=</span> <span class="n">aux_ifv</span>

        <span class="n">aux_list_anfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">lhs_anfs</span><span class="p">:</span>
            <span class="n">aux_anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
            <span class="c1"># aux_anf = BooleanPolynomialVector()</span>
            <span class="c1"># for component in anf:</span>
            <span class="c1">#     aux_anf.append(bpr(bpr(component).subs(initial_fixed_vars)))</span>
            <span class="n">aux_list_anfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">)</span>
        <span class="n">lhs_anfs</span> <span class="o">=</span> <span class="n">aux_list_anfs</span>
        <span class="n">aux_list_anfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">rhs_anfs</span><span class="p">:</span>
            <span class="n">aux_anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
            <span class="c1"># aux_anf = BooleanPolynomialVector()</span>
            <span class="c1"># for component in anf:</span>
            <span class="c1">#     aux_anf.append(bpr(bpr(component).subs(initial_fixed_vars)))</span>
            <span class="n">aux_list_anfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">)</span>
        <span class="n">rhs_anfs</span> <span class="o">=</span> <span class="n">aux_list_anfs</span>

        <span class="n">lhs_input_vars</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">anf_iv</span><span class="p">]</span> <span class="k">for</span> <span class="n">anf_iv</span> <span class="ow">in</span> <span class="n">lhs_input_vars</span><span class="p">]</span>
        <span class="n">rhs_input_vars</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">anf_iv</span><span class="p">]</span> <span class="k">for</span> <span class="n">anf_iv</span> <span class="ow">in</span> <span class="n">rhs_input_vars</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">initial_equations</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)):</span>
                    <span class="n">initial_equations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">initial_equations</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">,</span> <span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">find_redundant_equations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">find_redundant_equations</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">find_redundant_equations</span><span class="p">)):</span>
                    <span class="n">find_redundant_equations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">find_redundant_equations</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">find_redundant_equations</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">find_redundant_equations</span><span class="p">,</span> <span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initial_fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">bpr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">lhs_anfs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">anf</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">bpr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="k">break</span>
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">rhs_anfs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">anf</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">bpr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="k">break</span>
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">anf_iv</span> <span class="ow">in</span> <span class="n">lhs_input_vars</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">anf_iv</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">bpr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="k">break</span>
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">anf_iv</span> <span class="ow">in</span> <span class="n">rhs_input_vars</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">anf_iv</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">bpr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="k">break</span>
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">initial_equations</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">bpr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">find_redundant_equations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">find_redundant_equations</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">bpr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">lla</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_anfs</span><span class="p">)</span>
        <span class="n">aux_f</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;(&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;F&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lla</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;)&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lla</span><span class="p">)])</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">rhs_degrees</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;solving the functional equation </span><span class="si">{</span><span class="n">aux_f</span><span class="si">}</span><span class="s2"> = degrees(</span><span class="si">{</span><span class="n">rhs_degrees</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lra</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_anfs</span><span class="p">)</span>
            <span class="n">aux_g</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;(&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;G&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lra</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;)&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lra</span><span class="p">)])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;solving the functional equation </span><span class="si">{</span><span class="n">aux_f</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">aux_g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lhs_anfs</span><span class="p">))):</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- F</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">lhs_anfs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lhs_input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rhs_degrees</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rhs_anfs</span><span class="p">))):</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- G</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">rhs_anfs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rhs_input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;number of input variables:&quot;</span><span class="p">,</span> <span class="n">num_total_input_vars</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;number of symbolic coefficients:&quot;</span><span class="p">,</span> <span class="n">num_total_symbolic_coeffs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_fixed_vars</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;number of initial fixed vars:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_fixed_vars</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">initial_equations</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;number of initial equations:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">find_redundant_equations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;number of candidate redundant equations:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">find_redundant_equations</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input variables (</span><span class="si">{</span><span class="n">num_total_input_vars</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">all_varnames</span><span class="p">[:</span><span class="n">num_total_input_vars</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;symbolic coefficients (</span><span class="si">{</span><span class="n">num_total_symbolic_coeffs</span><span class="si">}</span><span class="s2">): &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">all_varnames</span><span class="p">[</span><span class="o">-</span><span class="n">num_total_symbolic_coeffs</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="n">bpr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_fixed_vars</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;initial fixed vars (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_fixed_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">initial_fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> &lt;- </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_equations</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;initial equations (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">initial_equations</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">_sp</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">find_redundant_equations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;initial equations (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">find_redundant_equations</span><span class="p">)</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">find_redundant_equations</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">_sp</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>  <span class="c1"># only new line after step</span>

    <span class="c1"># 2.1 Compute the concatenation of F and G</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | computing F and G&quot;</span><span class="p">)</span>

    <span class="n">lhs_composition_anf</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">index_anf</span><span class="p">,</span> <span class="n">anf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lhs_anfs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lhs_composition_anf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lhs_composition_anf</span> <span class="o">=</span> <span class="n">anf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_vars</span> <span class="o">=</span> <span class="n">lhs_input_vars</span><span class="p">[</span><span class="n">index_anf</span><span class="p">]</span>
            <span class="n">replacement</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">component</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">lhs_composition_anf</span><span class="p">)}</span>
            <span class="n">lhs_composition_anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rhs_degrees</span><span class="p">:</span>
        <span class="n">rhs_composition_anf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">index_anf</span><span class="p">,</span> <span class="n">anf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rhs_anfs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rhs_composition_anf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rhs_composition_anf</span> <span class="o">=</span> <span class="n">anf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">input_vars</span> <span class="o">=</span> <span class="n">rhs_input_vars</span><span class="p">[</span><span class="n">index_anf</span><span class="p">]</span>
                <span class="n">replacement</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">component</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">rhs_composition_anf</span><span class="p">)}</span>
                <span class="n">rhs_composition_anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;- F (after composition):&quot;</span><span class="p">)</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">lhs_composition_anf</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rhs_degrees</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;- G (after composition):&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">rhs_composition_anf</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rhs_degrees</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_composition_anf</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_degrees</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(lhs_composition_anf) = </span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2"> = len(rhs_degrees)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">lhs_composition_anf</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_degrees</span><span class="p">)</span>
            <span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_composition_anf</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_composition_anf</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(lhs_composition_anf) = </span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2"> = len(rhs_composition_anf)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">lhs_composition_anf</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_composition_anf</span><span class="p">)</span>
            <span class="p">))</span>

    <span class="c1"># 2.2 Compute the system of equations from F + G = 0</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | getting equations from F + G = 0&quot;</span><span class="p">)</span>

    <span class="n">equations</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span>
    <span class="n">index_eq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index_component</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lhs_composition_anf</span><span class="p">)):</span>
        <span class="c1"># if verbose:</span>
        <span class="c1">#     smart_print(f&quot;{get_time()} | getting symbolic coeffs of {index_component}-th component&quot;)</span>

        <span class="n">lhs_component</span> <span class="o">=</span> <span class="n">lhs_composition_anf</span><span class="p">[</span><span class="n">index_component</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rhs_degrees</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">rhs_degrees</span><span class="p">[</span><span class="n">index_component</span><span class="p">]</span>
            <span class="n">mon2coeff</span> <span class="o">=</span> <span class="n">get_all_symbolic_coeff</span><span class="p">(</span><span class="n">lhs_component</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ignore_terms_of_deg_strictly_less</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">monomial</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">mon2coeff</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">assert</span> <span class="n">monomial</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;found invalid equation 0 == 1&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">eq[</span><span class="si">{</span><span class="n">index_eq</span><span class="si">}</span><span class="s2">]: (</span><span class="si">{</span><span class="n">index_component</span><span class="si">}</span><span class="s2">-th component) &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;0 == coefficient(monomial=</span><span class="si">{</span><span class="n">monomial</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                <span class="n">index_eq</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">component</span> <span class="o">=</span> <span class="n">lhs_component</span> <span class="o">+</span> <span class="n">rhs_composition_anf</span><span class="p">[</span><span class="n">index_component</span><span class="p">]</span>
            <span class="n">input_vars</span> <span class="o">=</span> <span class="n">lhs_input_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">rhs_input_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">monomial</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">get_all_symbolic_coeff</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">input_vars</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;found invalid equation 0 == 1&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">eq[</span><span class="si">{</span><span class="n">index_eq</span><span class="si">}</span><span class="s2">]: coefficient(monomial=</span><span class="si">{</span><span class="n">monomial</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                <span class="n">index_eq</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">index_eq</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;no equation added from F + G = 0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_mode</span> <span class="o">==</span> <span class="s2">&quot;raw_equations&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">equations</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># 3. Reduce and find fixed/free vars</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reduction_mode</span><span class="p">:</span>
            <span class="n">aux</span> <span class="o">+=</span> <span class="s2">&quot; and reducing system&quot;</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | finding fixed and free variables</span><span class="si">{</span><span class="n">aux</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">return_mode</span> <span class="o">!=</span> <span class="s2">&quot;raw_equations&quot;</span>  <span class="c1"># no calls to find_fixed_vars() when &quot;raw_equations&quot; mode</span>
    <span class="n">fixed_vars</span><span class="p">,</span> <span class="n">equations</span> <span class="o">=</span> <span class="n">find_fixed_vars</span><span class="p">(</span>
        <span class="n">equations</span><span class="p">,</span> <span class="n">only_linear</span><span class="o">=</span><span class="n">only_linear_fixed_vars</span><span class="p">,</span>
        <span class="n">initial_r_mode</span><span class="o">=</span><span class="n">reduction_mode</span><span class="p">,</span> <span class="n">repeat_with_r_mode</span><span class="o">=</span><span class="n">reduction_mode</span><span class="p">,</span>
        <span class="n">initial_fixed_vars</span><span class="o">=</span><span class="n">initial_fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check_find_fixed_vars</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>

    <span class="n">eq_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
            <span class="n">eq_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
    <span class="n">eq_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">eq_vars</span><span class="p">)</span>
    <span class="n">free_vars</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">num_total_input_vars</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">eq_vars</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_vars</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore_varnames</span><span class="p">:</span>
            <span class="n">free_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
    <span class="n">eq_vars</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">eq_vars</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">fv_str</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fv_str_linear</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fv_str_ct</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">aux_v</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">v</span>
            <span class="n">fv_str</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">aux_v</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fv_str_linear</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">aux_v</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">fv_str_ct</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">aux_v</span><span class="p">))</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fixed variables (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fv_str</span><span class="p">)</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">fv_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fv_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fv_str_linear</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">only_linear_fixed_vars</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(linear) fixed variables (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fv_str_linear</span><span class="p">)</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">fv_str_linear</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fv_str_ct</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fv_str</span><span class="p">):</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(constant) fixed variables (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fv_str_ct</span><span class="p">)</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">fv_str_ct</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;free variables (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">free_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">free_vars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># if print_common_nonlinear_vars:</span>
    <span class="c1">#     raise NotImplementedError(&quot;print_common_nonlinear_vars not implemented&quot;)</span>

    <span class="c1"># 4. SAT solving</span>

    <span class="k">if</span> <span class="n">find_redundant_equations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> | finding redundant equations among </span><span class="si">{}</span><span class="s2"> given equations in:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">get_time</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">find_redundant_equations</span><span class="p">)))</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;base system with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">eq_vars</span><span class="p">)</span><span class="si">}</span><span class="s2"> variables&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;system variables: </span><span class="si">{</span><span class="n">eq_vars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># find_redundant_equations previous parsed to bpr</span>
        <span class="n">find_redundant_equations</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">find_redundant_equations</span><span class="p">,</span> <span class="n">fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>

        <span class="n">sat_varnames</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">eq_vars</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">find_redundant_equations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sat_varnames</span><span class="p">:</span>
                    <span class="n">sat_varnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">eq_vars</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sat_varnames</span><span class="p">):</span>
            <span class="n">aux_vars</span> <span class="o">=</span> <span class="n">sat_varnames</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">eq_vars</span><span class="p">):]</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">aux_vars</span><span class="p">)</span><span class="si">}</span><span class="s2"> variables from redundant equations&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;added variables: </span><span class="si">{</span><span class="n">aux_vars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">sat_bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">sat_varnames</span><span class="p">)</span>
        <span class="n">sat_base_problem</span> <span class="o">=</span> <span class="p">[</span><span class="n">sat_bpr</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">]</span>
        <span class="n">found_red_eqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">red_eq</span> <span class="ow">in</span> <span class="n">find_redundant_equations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">red_eq</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ignoring redundant equation 0 == </span><span class="si">{</span><span class="n">red_eq</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">red_eq</span> <span class="o">=</span> <span class="n">sat_bpr</span><span class="p">(</span><span class="n">red_eq</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | checking redundant equation </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">red_eq</span><span class="p">)</span><span class="si">}</span><span class="s2"> with SAT solver&quot;</span><span class="p">)</span>
            <span class="n">solutions</span> <span class="o">=</span> <span class="n">solve_sat</span><span class="p">(</span><span class="n">sat_base_problem</span> <span class="o">+</span> <span class="p">[</span><span class="n">red_eq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s_threads</span><span class="o">=</span><span class="n">threads</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">solutions</span><span class="p">:</span>
                <span class="n">found_red_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">red_eq</span><span class="p">))</span>
                <span class="n">sat_base_problem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">red_eq</span><span class="p">)</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">redundant equation found, all found up to now: </span><span class="si">{</span><span class="n">found_red_eqs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;redundant equations found (</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">found_red_eqs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">find_redundant_equations</span><span class="p">),</span> <span class="n">found_red_eqs</span><span class="p">))</span>
        <span class="n">found_red_eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">found_red_eqs</span><span class="p">]</span>  <span class="c1"># x is str</span>
        <span class="n">found_red_eqs</span> <span class="o">=</span> <span class="n">gauss_on_polys</span><span class="p">(</span><span class="n">found_red_eqs</span><span class="p">)</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;redundant equations found reduced with gauss (</span><span class="si">{}</span><span class="s2">):</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">found_red_eqs</span><span class="p">),</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">found_red_eqs</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">found_red_eqs</span>

    <span class="k">if</span> <span class="n">num_sat_solutions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_sat_solutions</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">infinity</span>

    <span class="k">if</span> <span class="n">equations</span> <span class="ow">and</span> <span class="n">eq_vars</span> <span class="ow">and</span> <span class="n">num_sat_solutions</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sat_bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">eq_vars</span><span class="p">])</span>
        <span class="n">sat_problem</span> <span class="o">=</span> <span class="p">[</span><span class="n">sat_bpr</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | solving </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sat_problem</span><span class="p">)</span><span class="si">}</span><span class="s2"> equations with &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">eq_vars</span><span class="p">)</span><span class="si">}</span><span class="s2"> variables using SAT solver&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;solver options: num_sat_solutions=</span><span class="si">{</span><span class="n">num_sat_solutions</span><span class="si">}</span><span class="s2">, threads=</span><span class="si">{</span><span class="n">threads</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ignore_varnames</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;, ignore_varnames=</span><span class="si">{</span><span class="n">ignore_varnames</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;system variables: </span><span class="si">{</span><span class="n">eq_vars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="n">target_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sat_bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore_varnames</span><span class="p">:</span>
                <span class="n">target_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">sat_solutions</span> <span class="o">=</span> <span class="n">solve_sat</span><span class="p">(</span>
            <span class="n">sat_problem</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">num_sat_solutions</span> <span class="k">if</span> <span class="n">num_sat_solutions</span> <span class="k">else</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">infinity</span><span class="p">,</span>
            <span class="n">target_variables</span><span class="o">=</span><span class="n">sat_bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">(),</span> <span class="n">s_threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># cryptominisat default, avoid passing solver objects</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sat_solutions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;system of equations is inconsistent (unsatisfiable)&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">equations</span> <span class="ow">or</span> <span class="n">num_sat_solutions</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">sat_solutions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># 5. Parsing solutions</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">sat_solutions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">equations</span><span class="p">:</span>
            <span class="n">num_total_solutions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_total_solutions</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_vars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | ignoring SAT solving step&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total number of solutions: </span><span class="si">{</span><span class="n">num_total_solutions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_total_solutions</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_vars</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sat_solutions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">num_total_solutions</span><span class="p">)</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;2^</span><span class="se">{{</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">aux</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;approx. 2^</span><span class="se">{{</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">ndigits</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | parsing </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sat_solutions</span><span class="p">)</span><span class="si">}</span><span class="s2"> SAT solutions found &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(total number of solutions </span><span class="si">{</span><span class="n">num_total_solutions</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">aux</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">SAT solutions:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;First 10 &quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sat_solutions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">sat_sol</span> <span class="ow">in</span> <span class="n">sat_solutions</span><span class="p">[:</span><span class="mi">10</span><span class="p">]:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{</span><span class="n">sat_sol</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">ordered_replacement</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">var2index_ordered_replacement</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index_var</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">()):</span>
            <span class="n">var2index_ordered_replacement</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_var</span>
            <span class="n">ordered_replacement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

    <span class="n">bpr_gens_dict</span> <span class="o">=</span> <span class="n">bpr</span><span class="o">.</span><span class="n">gens_dict</span><span class="p">()</span>

    <span class="n">extended_solutions</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># with the fixed vars substituted (but not the free vars)</span>
    <span class="k">for</span> <span class="n">index_sat_sol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sat_solutions</span><span class="p">)):</span>
        <span class="c1"># avoid printing</span>
        <span class="n">sat_sol</span> <span class="o">=</span> <span class="n">sat_solutions</span><span class="p">[</span><span class="n">index_sat_sol</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sat_sol</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">eq_vars</span><span class="p">)</span>

        <span class="n">sol_ordered_replacement</span> <span class="o">=</span> <span class="n">ordered_replacement</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ext_sol</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">sat_sol</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">str2bp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">bpr_gens_dict</span><span class="p">),</span> <span class="n">str2bp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">bpr_gens_dict</span><span class="p">)</span>
            <span class="n">ext_sol</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">sol_ordered_replacement</span><span class="p">[</span><span class="n">var2index_ordered_replacement</span><span class="p">[</span><span class="n">var</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">substitute_variables</span><span class="p">(</span><span class="n">bpr</span><span class="p">,</span> <span class="n">sol_ordered_replacement</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">ext_sol</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># ext_sol = sat_sol.copy()  # copy for fast .subs() below</span>
        <span class="c1">#</span>
        <span class="c1"># for var, value in fixed_vars.items():</span>
        <span class="c1">#     if value not in [0, 1]:</span>
        <span class="c1">#         value = value.subs(sat_sol)  # avoid casting to bpr for fast .subs()</span>
        <span class="c1">#     ext_sol[var] = value</span>

        <span class="n">extended_solutions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ext_sol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_sols_per_base_sol_to_check</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ext_sol</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">assert</span> <span class="n">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">ext_sol</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">free_vars</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">variables</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">index_sol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">num_sols_per_base_sol_to_check</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="nb">len</span><span class="p">(</span><span class="n">free_vars</span><span class="p">))):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">free_vars</span><span class="p">:</span>
                    <span class="n">full_sol</span> <span class="o">=</span> <span class="n">ext_sol</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">full_sol</span> <span class="o">=</span> <span class="n">ext_sol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">free_vars_var2value</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">free_vars</span><span class="p">,</span> <span class="n">int2vector</span><span class="p">(</span><span class="n">index_sol</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_vars</span><span class="p">))):</span>
                        <span class="n">free_vars_var2value</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">full_sol</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="n">full_sol</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">free_vars_var2value</span><span class="p">)</span>
                    <span class="n">full_sol</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">full_sol</span><span class="p">,</span> <span class="o">**</span><span class="n">free_vars_var2value</span><span class="p">}</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Base solution </span><span class="si">{</span><span class="n">index_sat_sol</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sat_solutions</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span> \
                      <span class="sa">f</span><span class="s2">&quot;checking full solution </span><span class="si">{</span><span class="n">index_sol</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">num_sols_per_base_sol_to_check</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; - sat solution                          : </span><span class="si">{</span><span class="n">sat_sol</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; - sat solution + fixed vars             : </span><span class="si">{</span><span class="n">ext_sol</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">free_vars</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; - sat solution + fixed vars + free vars : </span><span class="si">{</span><span class="n">full_sol</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">val</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">full_sol</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">msg</span>
                <span class="n">full_sol</span> <span class="o">=</span> <span class="p">{</span><span class="n">bpr</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">full_sol</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="k">for</span> <span class="n">index_eq</span><span class="p">,</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">):</span>
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">!=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">full_sol</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;0 != initial_equations[</span><span class="si">{</span><span class="n">index_eq</span><span class="si">}</span><span class="s2">].subs(&quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;full_sol=</span><span class="si">{</span><span class="n">full_sol</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">full_sol</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">aux_lhs_anfs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">lhs_anfs</span><span class="p">:</span>
                    <span class="n">aux_anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">full_sol</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                    <span class="c1"># aux_anf = BooleanPolynomialVector()</span>
                    <span class="c1"># for component in anf:</span>
                    <span class="c1">#     aux_anf.append(bpr(component.subs(full_sol)))</span>
                    <span class="n">aux_lhs_anfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">)</span>
                <span class="n">aux_lhs_composition_anf</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">index_anf</span><span class="p">,</span> <span class="n">anf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">aux_lhs_anfs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">aux_lhs_composition_anf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">aux_lhs_composition_anf</span> <span class="o">=</span> <span class="n">anf</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">input_vars</span> <span class="o">=</span> <span class="n">lhs_input_vars</span><span class="p">[</span><span class="n">index_anf</span><span class="p">]</span>
                        <span class="n">replacement</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">component</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">aux_lhs_composition_anf</span><span class="p">)}</span>
                        <span class="n">aux_lhs_composition_anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; - F:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">aux_lhs_composition_anf</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rhs_degrees</span><span class="p">:</span>
                    <span class="n">aux_rhs_anfs</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">rhs_anfs</span><span class="p">:</span>
                        <span class="n">aux_anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">full_sol</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                        <span class="c1"># aux_anf = BooleanPolynomialVector()</span>
                        <span class="c1"># for component in anf:</span>
                        <span class="c1">#     aux_anf.append(bpr(component.subs(full_sol)))</span>
                        <span class="n">aux_rhs_anfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">)</span>
                    <span class="n">aux_rhs_composition_anf</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">index_anf</span><span class="p">,</span> <span class="n">anf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">aux_rhs_anfs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">aux_rhs_composition_anf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">aux_rhs_composition_anf</span> <span class="o">=</span> <span class="n">anf</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">input_vars</span> <span class="o">=</span> <span class="n">rhs_input_vars</span><span class="p">[</span><span class="n">index_anf</span><span class="p">]</span>
                            <span class="n">replacement</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">component</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">aux_rhs_composition_anf</span><span class="p">)}</span>
                            <span class="n">aux_rhs_composition_anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; - G:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">get_anf_coeffmatrix_str</span><span class="p">(</span><span class="n">aux_rhs_composition_anf</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aux_lhs_composition_anf</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">rhs_degrees</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">get_symbolic_alg_deg</span><span class="p">(</span><span class="n">aux_lhs_composition_anf</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span> <span class="n">lhs_input_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="n">rhs_degrees</span><span class="p">[</span><span class="n">ic</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;degree(F[</span><span class="si">{</span><span class="n">ic</span><span class="si">}</span><span class="s2">]) = </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">rhs_degrees</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span><span class="si">}</span><span class="s2"> = degree(G[</span><span class="si">{</span><span class="n">ic</span><span class="si">}</span><span class="s2">])</span><span class="se">\n</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">component</span> <span class="o">=</span> <span class="n">aux_lhs_composition_anf</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">+</span> <span class="n">aux_rhs_composition_anf</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">component</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;0 != F[</span><span class="si">{</span><span class="n">ic</span><span class="si">}</span><span class="s2">] + G[</span><span class="si">{</span><span class="n">ic</span><span class="si">}</span><span class="s2">] = </span><span class="si">{</span><span class="n">component</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">index_sat_sol</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">index_sol</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="n">msg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># without the last \n</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># 6. Finding linear combinations</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sat_solutions</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_sat_solutions</span><span class="p">:</span>
        <span class="n">find_linear_combinations_in_solutions</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">linear_combinations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">sat_solutions</span> <span class="ow">and</span> <span class="n">find_linear_combinations_in_solutions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | finding linear combinations of variables among the SAT solutions&quot;</span><span class="p">)</span>

        <span class="c1"># each &quot;column&quot; of sat_solutions.values() contains the values each var takes for each sol</span>
        <span class="c1"># we need each column as a set of vectors to call V.linear_dependence(vectors)</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">sat_sol</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">sat_sol</span> <span class="ow">in</span> <span class="n">sat_solutions</span><span class="p">)))</span>  <span class="c1"># transpose</span>
        <span class="c1"># before that we need to sort vectors s.t. smallest var is the last vector</span>
        <span class="n">vars_in_vectors</span> <span class="o">=</span> <span class="p">[(</span><span class="n">var</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sat_solutions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
        <span class="n">vars_in_vectors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">vars_in_vectors</span><span class="p">)))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">vars_in_vectors</span><span class="p">)</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vars_in_vectors</span><span class="p">:</span>
            <span class="n">aux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">aux</span>
        <span class="n">vars_in_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">vars_in_vectors</span><span class="p">]</span>
        <span class="c1"># to detect linear combinations equal to 1 (instead of 0) we add 1 to the end</span>
        <span class="n">vectors</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]))])</span>
        <span class="n">vars_in_vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sat_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">vs</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">VectorSpace</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">vars_in_vectors</span><span class="p">))</span>
        <span class="n">linear_combinations_matrix</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">sat_bpr</span><span class="p">,</span> <span class="n">vs</span><span class="o">.</span><span class="n">linear_dependence</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">linear_combinations_matrix</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">linear_combinations</span> <span class="o">=</span> <span class="n">linear_combinations_matrix</span> <span class="o">*</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="n">vars_in_vectors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;linear combinations (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">linear_combinations</span><span class="p">)</span><span class="si">}</span><span class="s2">): &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span> <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="n">linear_combinations</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">linear_combinations</span><span class="p">:</span>
            <span class="n">aux_matrix</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span>
                <span class="n">nrows</span><span class="o">=</span><span class="n">linear_combinations_matrix</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="n">linear_combinations_matrix</span><span class="o">.</span><span class="n">ncols</span><span class="p">(),</span>
                <span class="n">entries</span><span class="o">=</span><span class="n">vars_in_vectors</span> <span class="o">+</span> <span class="n">linear_combinations_matrix</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">aux_matrix</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="n">row_lines</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;linear combinations (matrix form)</span><span class="se">\n</span><span class="si">{</span><span class="n">aux_matrix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_mode</span> <span class="o">==</span> <span class="s2">&quot;lincomb_solutions&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">bpr</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span> <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="n">linear_combinations</span><span class="p">]</span>

    <span class="c1"># 7. Reducing system if linear combinations are found</span>

    <span class="k">if</span> <span class="n">linear_combinations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | reducing system with the linear combinations obtained&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="n">linear_combinations</span><span class="p">:</span>
            <span class="n">equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">lc</span><span class="p">))</span>

        <span class="n">new_fixed_vars</span><span class="p">,</span> <span class="n">new_equations</span> <span class="o">=</span> <span class="n">find_fixed_vars</span><span class="p">(</span>
            <span class="n">equations</span><span class="p">,</span> <span class="n">only_linear</span><span class="o">=</span><span class="n">only_linear_fixed_vars</span><span class="p">,</span>
            <span class="n">initial_r_mode</span><span class="o">=</span><span class="n">reduction_mode</span><span class="p">,</span> <span class="n">repeat_with_r_mode</span><span class="o">=</span><span class="n">reduction_mode</span><span class="p">,</span>
            <span class="n">initial_fixed_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bpr</span><span class="o">=</span><span class="n">bpr</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check_find_fixed_vars</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">fixed_vars_modified</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_fixed_vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_expr</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">new_fixed_vars</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="o">!=</span> <span class="n">new_expr</span><span class="p">:</span>
                <span class="n">fixed_vars</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_expr</span>
                <span class="n">fixed_vars_modified</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">new_fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_vars</span>
            <span class="n">fixed_vars</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span>

        <span class="n">new_eq_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">new_equations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                <span class="n">new_eq_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="n">new_eq_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bpr</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">new_eq_vars</span><span class="p">)</span>
        <span class="n">new_free_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">num_total_input_vars</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_eq_vars</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_vars</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_fixed_vars</span><span class="p">:</span>
                <span class="n">new_free_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="n">new_eq_vars</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">new_eq_vars</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fixed_vars_modified</span><span class="p">:</span>
                <span class="n">fv_str</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">fv_str_linear</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">fv_str_ct</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fixed_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">aux_v</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">v</span>
                    <span class="n">fv_str</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">aux_v</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">fv_str_linear</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">aux_v</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">fv_str_ct</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">aux_v</span><span class="p">))</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fixed variables (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fv_str</span><span class="p">)</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">fv_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fv_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fv_str_linear</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">only_linear_fixed_vars</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(linear) fixed variables (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fv_str_linear</span><span class="p">)</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">fv_str_linear</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fv_str_ct</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fv_str</span><span class="p">):</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(constant) fixed variables (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fv_str_ct</span><span class="p">)</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">fv_str_ct</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">free_vars</span> <span class="o">!=</span> <span class="n">new_free_vars</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;free variables (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_free_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">new_free_vars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_free_vars</span><span class="p">))</span> <span class="o">!=</span> <span class="n">num_total_solutions</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2^</span><span class="se">{{</span><span class="s2">number_free_vars=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_free_vars</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s2"> != &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">math</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">num_total_solutions</span><span class="p">)</span><span class="si">}</span><span class="s2"> = number_solutions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">eq_vars</span> <span class="o">!=</span> <span class="n">new_eq_vars</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;number of system variables changed to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_eq_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;system variables (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_eq_vars</span><span class="p">)</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">new_eq_vars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_fixed_vars</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;number of equations changed to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_equations</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">index_eq</span><span class="p">,</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_equations</span><span class="p">):</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">eq[</span><span class="si">{</span><span class="n">index_eq</span><span class="si">}</span><span class="s2">] = </span><span class="si">{</span><span class="n">_sp</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># if print_common_nonlinear_vars:</span>
        <span class="c1">#     raise NotImplementedError(&quot;print_common_nonlinear_vars not implemented&quot;)</span>

        <span class="n">equations</span> <span class="o">=</span> <span class="n">new_equations</span>
        <span class="n">free_vars</span> <span class="o">=</span> <span class="n">new_free_vars</span>
        <span class="n">eq_vars</span> <span class="o">=</span> <span class="n">new_eq_vars</span>

    <span class="c1"># 8. Returning solutions</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | returning outputs with mode=&#39;</span><span class="si">{</span><span class="n">return_mode</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_mode</span> <span class="o">==</span> <span class="s2">&quot;list_coeffs&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_total_num_solutions</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extended_solutions</span><span class="p">,</span> <span class="n">free_vars</span><span class="p">,</span> <span class="n">num_total_solutions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extended_solutions</span><span class="p">,</span> <span class="n">free_vars</span>

    <span class="k">if</span> <span class="n">return_mode</span> <span class="o">==</span> <span class="s2">&quot;list_anfs&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extended_solutions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">extended_solutions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fixed_vars</span><span class="p">)</span>  <span class="c1"># SAT solver was not called</span>
        <span class="k">if</span> <span class="n">free_vars</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;setting to 0 the free variables </span><span class="si">{</span><span class="n">free_vars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">free_vars_var2value</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">free_vars</span><span class="p">:</span>
                <span class="n">free_vars_var2value</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">list_anfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">input_var_bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="n">num_total_input_vars</span><span class="p">,</span> <span class="n">all_varnames</span><span class="p">[:</span><span class="n">num_total_input_vars</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">extended_sol</span> <span class="ow">in</span> <span class="n">extended_solutions</span><span class="p">:</span>
            <span class="n">extended_sol</span> <span class="o">=</span> <span class="p">{</span><span class="n">bpr</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">extended_sol</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">if</span> <span class="n">free_vars</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">extended_sol</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">extended_sol</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">bpr</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">free_vars_var2value</span><span class="p">))</span>
                <span class="n">extended_sol</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">extended_sol</span><span class="p">,</span> <span class="o">**</span><span class="n">free_vars_var2value</span><span class="p">}</span>
            <span class="n">aux_lhs_anfs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">lhs_anfs</span><span class="p">:</span>
                <span class="n">anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">extended_sol</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                <span class="n">aux_anf</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">anf</span><span class="p">:</span>
                    <span class="n">aux_anf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_var_bpr</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>
                <span class="c1"># aux_anf = BooleanPolynomialVector()</span>
                <span class="c1"># for component in anf:</span>
                <span class="c1">#     aux_anf.append(input_var_bpr(bpr(component.subs(extended_sol))))</span>
                <span class="n">aux_lhs_anfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rhs_degrees</span><span class="p">:</span>
                <span class="n">list_anfs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aux_lhs_anfs</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux_rhs_anfs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">rhs_anfs</span><span class="p">:</span>
                    <span class="n">anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">extended_sol</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                    <span class="n">aux_anf</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">anf</span><span class="p">:</span>
                        <span class="n">aux_anf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_var_bpr</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>
                    <span class="c1"># aux_anf = BooleanPolynomialVector()</span>
                    <span class="c1"># for component in anf:</span>
                    <span class="c1">#     aux_anf.append(input_var_bpr(bpr(component.subs(extended_sol))))</span>
                    <span class="n">aux_rhs_anfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">)</span>
                <span class="n">list_anfs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aux_lhs_anfs</span><span class="p">,</span> <span class="n">aux_rhs_anfs</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">return_total_num_solutions</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">list_anfs</span><span class="p">,</span> <span class="n">num_total_solutions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">list_anfs</span>

    <span class="k">if</span> <span class="n">return_mode</span> <span class="o">==</span> <span class="s2">&quot;symbolic_anf&quot;</span><span class="p">:</span>
        <span class="n">aux_lhs_anfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">lhs_anfs</span><span class="p">:</span>
            <span class="n">aux_anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
            <span class="c1"># aux_anf = BooleanPolynomialVector()</span>
            <span class="c1"># for component in anf:</span>
            <span class="c1">#     aux_anf.append(bpr(component.subs(fixed_vars)))</span>
            <span class="n">aux_lhs_anfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs_degrees</span><span class="p">:</span>
            <span class="n">symbolic_anf</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_lhs_anfs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aux_rhs_anfs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">anf</span> <span class="ow">in</span> <span class="n">rhs_anfs</span><span class="p">:</span>
                <span class="n">aux_anf</span> <span class="o">=</span> <span class="n">substitute_anf</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">fixed_vars</span><span class="p">,</span> <span class="n">bpr</span><span class="p">)</span>
                <span class="c1"># aux_anf = BooleanPolynomialVector()</span>
                <span class="c1"># for component in anf:</span>
                <span class="c1">#     aux_anf.append(bpr(component.subs(fixed_vars)))</span>
                <span class="n">aux_rhs_anfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_anf</span><span class="p">)</span>
            <span class="n">symbolic_anf</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_lhs_anfs</span><span class="p">,</span> <span class="n">aux_rhs_anfs</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_total_num_solutions</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbolic_anf</span><span class="p">,</span> <span class="n">equations</span><span class="p">,</span> <span class="n">num_total_solutions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">symbolic_anf</span><span class="p">,</span> <span class="n">equations</span>

    <span class="k">if</span> <span class="n">return_mode</span> <span class="o">==</span> <span class="s2">&quot;symbolic_coeffs&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_total_num_solutions</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fixed_vars</span><span class="p">,</span> <span class="n">equations</span><span class="p">,</span> <span class="n">num_total_solutions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fixed_vars</span><span class="p">,</span> <span class="n">equations</span></div>


<div class="viewcode-block" id="find_inverse"><a class="viewcode-back" href="../../boolcrypt.functionalequations.html#boolcrypt.functionalequations.find_inverse">[docs]</a><span class="k">def</span> <span class="nf">find_inverse</span><span class="p">(</span>
    <span class="n">anf</span><span class="p">,</span> <span class="n">inv_degree</span><span class="p">,</span> <span class="n">inv_position</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>  <span class="c1"># input_vars=None,</span>
    <span class="n">prefix_inv_coeffs</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">solve_args</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the inverse of an ANF by calling solve_functional_equation().</span>

<span class="sd">    Given a function F, find A s.t. A(F) = Identity if inv_position=&quot;left&quot;.</span>
<span class="sd">    If inv_position=&quot;right&quot;,  find A&#39; s.t. F(A) = Identity.</span>
<span class="sd">    If no inverse is found, None returned.</span>

<span class="sd">    This method does not support symbolic ANF, and the input function F</span>
<span class="sd">    must be defined in the boolean polynomial ring</span>
<span class="sd">    BooleanPolynomialRing(n,&#39;x&#39;) with n the number of input variables.</span>

<span class="sd">    Named arguments from ``**solve_args`` are passed to solve_functional_equation().</span>
<span class="sd">    By default, return_mode=&quot;list_anfs&quot; and num_sat_solutions=&quot;1&quot;.</span>
<span class="sd">    If these two parameters are not given, only one solution is found</span>
<span class="sd">    and the ANF of the inverse is returned.</span>

<span class="sd">        &gt;&gt;&gt; sage.all.set_random_seed(0)</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import lut2anf, matrix2anf, compose_anf_fast</span>
<span class="sd">        &gt;&gt;&gt; anf = lut2anf((0, 1, 2, 3, 4, 6, 7, 5))</span>
<span class="sd">        &gt;&gt;&gt; inv_anf = find_inverse(anf, 2)</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(inv_anf)  # , input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [x0*x2 x1*x2|   x0    x1    x2]</span>
<span class="sd">        [-----------+-----------------]</span>
<span class="sd">        [    0     1|    1     0     0]</span>
<span class="sd">        [    1     1|    0     1     0]</span>
<span class="sd">        [    0     0|    0     0     1]</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(compose_anf_fast(inv_anf, anf), input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [x0 x1 x2]</span>
<span class="sd">        [--------]</span>
<span class="sd">        [ 1  0  0]</span>
<span class="sd">        [ 0  1  0]</span>
<span class="sd">        [ 0  0  1]</span>
<span class="sd">        &gt;&gt;&gt; matrix = sage.all.matrix(GF(2), 2, 3, [[1, 1, 0], [1, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; anf = matrix2anf(matrix)</span>
<span class="sd">        &gt;&gt;&gt; result = find_inverse(anf, 1, inv_position=&quot;right&quot;, return_mode=&quot;symbolic_anf&quot;, num_sat_solutions=None)</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(result[0][0][0], input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [      x0       x1       x2|       1]</span>
<span class="sd">        [--------------------------+--------]</span>
<span class="sd">        [a1_0 + 1     a1_1     a1_2|      a1]</span>
<span class="sd">        [    a1_0     a1_1     a1_2|      a1]</span>
<span class="sd">        [       1        1        0|       0]</span>
<span class="sd">        &gt;&gt;&gt; list(result[1])  # equations</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; matrix * anf2matrix(result[0][0][0], input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [1 0 0]</span>
<span class="sd">        [0 1 0]</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        The list of the inputs vars (containing Boolean variables</span>
<span class="sd">        or strings) of the given anf (not needed for non-symbolic anf)</span>
<span class="sd">        is not given since this method only supports non-symbolic ANF.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">inv_position</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>

    <span class="c1"># # deprecated</span>
    <span class="c1"># if solve_args.get(&quot;bpr&quot;, None) is not None:</span>
    <span class="c1">#     assert solve_args.get(&quot;ignore_initial_parsing&quot;, False) is not True</span>
    <span class="c1"># # bpr = solve_args.get(&quot;bpr&quot;, None)</span>
    <span class="c1"># # initial_fixed_vars = solve_args.get(&quot;initial_fixed_vars&quot;, {})</span>
    <span class="c1"># # initial_fixed_vars = collections.OrderedDict(</span>
    <span class="c1"># #     [(k, v) for k, v in initial_fixed_vars.items() if str(k).startswith(prefix_inv_coeffs)])</span>
    <span class="c1"># if input_vars is None:</span>
    <span class="c1">#     aux_bpr = anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in anf)</span>
    <span class="c1">#     input_vars = list(aux_bpr.gens())</span>

    <span class="n">input_vars</span> <span class="o">=</span> <span class="n">anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>

    <span class="n">bpr_x</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_vars</span><span class="p">),</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bpr&quot;</span><span class="p">,</span> <span class="n">bpr_x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">solve_args</span><span class="p">[</span><span class="s1">&#39;bpr&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_inv_coeffs</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">input_vars</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_inv_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inv_position</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">inv_degree</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">),</span>
                              <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_inv_coeffs</span><span class="p">)</span>
                              <span class="c1"># bpr=bpr, coeff2expr=initial_fixed_vars)</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="n">anf</span>
        <span class="n">f1_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">))]</span>
        <span class="n">f0_input_vars</span> <span class="o">=</span> <span class="n">input_vars</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">anf</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">inv_degree</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_vars</span><span class="p">),</span>
                              <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_inv_coeffs</span><span class="p">)</span>
                              <span class="c1"># bpr=bpr, coeff2expr=initial_fixed_vars)</span>
        <span class="n">f1_input_vars</span> <span class="o">=</span> <span class="n">input_vars</span>
        <span class="n">f0_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_vars</span><span class="p">))]</span>

    <span class="c1"># if bpr is not None:</span>
    <span class="c1">#     f0_input_vars = [bpr(v) for v in f0_input_vars]</span>
    <span class="c1">#     f1_input_vars = [bpr(v) for v in f1_input_vars]</span>

    <span class="n">lhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">]</span>
    <span class="n">lhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0_input_vars</span><span class="p">,</span> <span class="n">f1_input_vars</span><span class="p">]</span>

    <span class="n">g_bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f1_input_vars</span><span class="p">),</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">g_bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
    <span class="n">g0</span> <span class="o">=</span> <span class="n">g_bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">()[:</span><span class="nb">len</span><span class="p">(</span><span class="n">f1</span><span class="p">)]</span>
    <span class="n">g0_input_vars</span> <span class="o">=</span> <span class="n">g_bpr</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
    <span class="c1"># if bpr is not None:</span>
    <span class="c1">#     g0 = [bpr(component) for component in g0]</span>
    <span class="c1">#     g0_input_vars = [bpr(v) for v in g0_input_vars]</span>
    <span class="n">rhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0</span><span class="p">]</span>
    <span class="n">rhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0_input_vars</span><span class="p">]</span>

    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;num_sat_solutions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;list_anfs&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">solve_functional_equation</span><span class="p">(</span>
            <span class="n">lhs_anfs</span><span class="p">,</span> <span class="n">rhs_anfs</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="sa">f</span><span class="s2">&quot;No solution found (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span> <span class="ow">and</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_total_num_solutions&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="s2">&quot;ignoring return_total_num_solutions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inv_position</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># return f1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># return f0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="find_equivalence"><a class="viewcode-back" href="../../boolcrypt.functionalequations.html#boolcrypt.functionalequations.find_equivalence">[docs]</a><span class="k">def</span> <span class="nf">find_equivalence</span><span class="p">(</span>
    <span class="n">left_anf</span><span class="p">,</span> <span class="n">right_anf</span><span class="p">,</span> <span class="n">left_equiv_degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">right_equiv_degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">equiv_ct_terms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># left_input_vars=None, right_input_vars=None,</span>
    <span class="n">prefix_left_equiv_coeffs</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">prefix_right_equiv_coeffs</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
    <span class="n">add_invertibility_equations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">solve_args</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find a pair of functions (A, B) such that B F A = G.</span>

<span class="sd">    Given the left function F and the right function G,</span>
<span class="sd">    this method finds a pair of functions (A, B) of given degrees</span>
<span class="sd">    such that B F A = G. If no solution is found, None is returned.</span>

<span class="sd">    If given degrees are 1 and equiv_ct_terms=True (resp. False),</span>
<span class="sd">    this methods finds whether F and G are affine (resp. linear) equivalent.</span>
<span class="sd">    Note that right_equiv_degree affects the right equivalence A and</span>
<span class="sd">    left_equiv_degree affects the left equivalence B.</span>

<span class="sd">    If F and G are the same, this methods finds self-equivalences.</span>

<span class="sd">    The pair (A, B) is found by solving the functional equation B F A = G.</span>

<span class="sd">    The parameter add_invertibility_equations can be [False, &quot;right&quot;, &quot;left&quot;, &quot;both&quot;].</span>
<span class="sd">    If &quot;right&quot; or &quot;both&quot;, an additional constraint is added to ensure</span>
<span class="sd">    the affine function B is a permutation (only supported with degree=1).</span>
<span class="sd">    If &quot;left&quot; or &quot;both&quot;, an additional constraint is added to ensure</span>
<span class="sd">    the affine function A is a permutation (only supported with degree=1).</span>
<span class="sd">    If False, no additional constraint is added regarding invertibility.</span>
<span class="sd">    Note that if F and G are permutations with the same input size,</span>
<span class="sd">    then no invertibility constraint is needed.</span>

<span class="sd">    This method does not support symbolic ANF, and the input functions F and G</span>
<span class="sd">    must be defined in the boolean polynomial ring</span>
<span class="sd">    BooleanPolynomialRing(n, &#39;x&#39;) with n the number of input variables.</span>

<span class="sd">    Named arguments from ``**solve_args`` are passed to solve_functional_equation().</span>
<span class="sd">    By default, return_mode=&quot;list_anfs&quot; and num_sat_solutions=&quot;1&quot;.</span>
<span class="sd">    If these two parameters are not given, only one solution is found</span>
<span class="sd">    and a pair containing the ANF of A and B is returned.</span>

<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import lut2anf, get_lut_inversion</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.equivalence import get_linear_repr</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.equivalence import check_self_le_anf</span>
<span class="sd">        &gt;&gt;&gt; left_anf = lut2anf([0, 1, 2, 3, 4, 6, 7, 5])</span>
<span class="sd">        &gt;&gt;&gt; right_anf = lut2anf(get_linear_repr([0, 1, 2, 3, 4, 6, 7, 5]))</span>
<span class="sd">        &gt;&gt;&gt; right_lin, left_lin = find_equivalence(left_anf, right_anf, equiv_ct_terms=False)  # linear</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(right_lin, input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [x0 x1 x2]</span>
<span class="sd">        [--------]</span>
<span class="sd">        [ 0  1  0]</span>
<span class="sd">        [ 1  1  1]</span>
<span class="sd">        [ 0  0  1]</span>
<span class="sd">        &gt;&gt;&gt; right_anf = lut2anf([x.__xor__(1) for x in [0, 1, 2, 3, 4, 6, 7, 5]])</span>
<span class="sd">        &gt;&gt;&gt; find_equivalence(left_anf, right_anf, equiv_ct_terms=False)</span>
<span class="sd">        No solution found (found invalid equation 0 == 1)</span>
<span class="sd">        &gt;&gt;&gt; right_aff, left_aff = find_equivalence(left_anf, right_anf, equiv_ct_terms=True)  # affine</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(right_aff, input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [x0 x1 x2| 1]</span>
<span class="sd">        [--------+--]</span>
<span class="sd">        [ 0  1  0| 0]</span>
<span class="sd">        [ 1  0  0| 0]</span>
<span class="sd">        [ 0  0  1| 1]</span>
<span class="sd">        &gt;&gt;&gt; find_equivalence(left_anf, lut2anf(get_lut_inversion(3)))</span>
<span class="sd">        No solution found (system of equations is inconsistent (unsatisfiable))</span>
<span class="sd">        &gt;&gt;&gt; right_se, left_se = find_equivalence(left_anf, left_anf, 1, 1, equiv_ct_terms=False)  # linear SE</span>
<span class="sd">        &gt;&gt;&gt; assert check_self_le_anf(left_anf, right_se, left_se, None)</span>
<span class="sd">        &gt;&gt;&gt; right_se, left_se = find_equivalence(left_anf, left_anf, 2, 2, equiv_ct_terms=False)  # non-linear SE</span>
<span class="sd">        &gt;&gt;&gt; assert check_self_le_anf(left_anf, right_se, left_se, None)</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(right_se, input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [x0*x1 x0*x2 x1*x2|   x0    x1    x2]</span>
<span class="sd">        [-----------------+-----------------]</span>
<span class="sd">        [    0     0     0|    0     1     1]</span>
<span class="sd">        [    1     1     1|    0     1     1]</span>
<span class="sd">        [    0     0     0|    1     0     1]</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        The two lists with the inputs vars</span>
<span class="sd">        (containing Boolean variables or strings) of the given F and G</span>
<span class="sd">        (not needed for non-symbolic anfs)</span>
<span class="sd">        is not given since this method only supports non-symbolic ANF.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">add_invertibility_equations</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">]</span>

    <span class="c1"># # deprecated</span>
    <span class="c1"># if solve_args.get(&quot;bpr&quot;, None) is not None:</span>
    <span class="c1">#     assert solve_args.get(&quot;ignore_initial_parsing&quot;, False) is not True</span>
    <span class="c1">#</span>
    <span class="c1"># # bpr = solve_args.get(&quot;bpr&quot;, None)</span>
    <span class="c1"># # initial_fixed_vars = solve_args.get(&quot;initial_fixed_vars&quot;, {})</span>
    <span class="c1"># # initial_fixed_vars = collections.OrderedDict(</span>
    <span class="c1"># #     [(k, v) for k, v in initial_fixed_vars.items() if str(k).startswith(prefix_left_equiv_coeffs) or</span>
    <span class="c1"># #      str(k).startswith(prefix_right_equiv_coeffs)])</span>
    <span class="c1">#</span>
    <span class="c1"># if left_input_vars is None:</span>
    <span class="c1">#     aux_bpr = left_anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in left_anf)</span>
    <span class="c1">#     left_input_vars = aux_bpr.gens()</span>
    <span class="c1"># if right_input_vars is None:</span>
    <span class="c1">#     aux_bpr = right_anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in right_anf)</span>
    <span class="c1">#     right_input_vars = aux_bpr.gens()</span>

    <span class="n">left_input_vars</span> <span class="o">=</span> <span class="n">left_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
    <span class="n">right_input_vars</span> <span class="o">=</span> <span class="n">right_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>

    <span class="n">bpr_x</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">)),</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bpr&quot;</span><span class="p">,</span> <span class="n">bpr_x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">solve_args</span><span class="p">[</span><span class="s1">&#39;bpr&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">left_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">right_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">,</span> <span class="n">right_input_vars</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_left_equiv_coeffs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_right_equiv_coeffs</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_left_equiv_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_right_equiv_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>

    <span class="n">f2</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">left_equiv_degree</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_anf</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_anf</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">equiv_ct_terms</span><span class="p">,</span>
                          <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_left_equiv_coeffs</span><span class="p">)</span>
                          <span class="c1"># bpr=bpr, coeff2expr=initial_fixed_vars)</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">left_anf</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">right_equiv_degree</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">equiv_ct_terms</span><span class="p">,</span>
                          <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_right_equiv_coeffs</span><span class="p">)</span>
                          <span class="c1"># bpr=bpr, coeff2expr=initial_fixed_vars)</span>
    <span class="n">f2_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_anf</span><span class="p">))]</span>
    <span class="n">f1_input_vars</span> <span class="o">=</span> <span class="n">left_input_vars</span>
    <span class="n">f0_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">))]</span>

    <span class="c1"># if bpr is not None:</span>
    <span class="c1">#     f2_input_vars = [bpr(v) for v in f2_input_vars]</span>
    <span class="c1">#     f0_input_vars = [bpr(v) for v in f0_input_vars]</span>

    <span class="n">g0</span> <span class="o">=</span> <span class="n">right_anf</span>
    <span class="n">g0_input_vars</span> <span class="o">=</span> <span class="n">right_input_vars</span>

    <span class="n">lhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">]</span>
    <span class="n">lhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0_input_vars</span><span class="p">,</span> <span class="n">f1_input_vars</span><span class="p">,</span> <span class="n">f2_input_vars</span><span class="p">]</span>

    <span class="n">rhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0</span><span class="p">]</span>
    <span class="n">rhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0_input_vars</span><span class="p">]</span>

    <span class="n">initial_equations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">add_invertibility_equations</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="n">right_equiv_degree</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">f0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="n">aux_iv</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f0_input_vars</span><span class="p">]</span>
        <span class="n">initial_equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">anf2matrix</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">aux_iv</span><span class="p">)</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span> <span class="o">+</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">add_invertibility_equations</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="n">left_equiv_degree</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">f2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="n">aux_iv</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f2_input_vars</span><span class="p">]</span>
        <span class="n">initial_equations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">anf2matrix</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">aux_iv</span><span class="p">)</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span> <span class="o">+</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;num_sat_solutions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;list_anfs&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;initial_equations&quot;</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;initial_equations&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;initial_equations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_equations</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">solve_functional_equation</span><span class="p">(</span>
            <span class="n">lhs_anfs</span><span class="p">,</span> <span class="n">rhs_anfs</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="sa">f</span><span class="s2">&quot;No solution found (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span> <span class="ow">and</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_total_num_solutions&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="s2">&quot;ignoring return_total_num_solutions&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># return f0, f2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="find_half_affine_equivalence"><a class="viewcode-back" href="../../boolcrypt.functionalequations.html#boolcrypt.functionalequations.find_half_affine_equivalence">[docs]</a><span class="k">def</span> <span class="nf">find_half_affine_equivalence</span><span class="p">(</span>
    <span class="n">left_anf</span><span class="p">,</span> <span class="n">inv_right_anf</span><span class="p">,</span>
    <span class="c1"># left_input_vars=None, inv_right_input_vars=None,</span>
    <span class="n">prefix_equiv_coeffs</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">add_invertibility_equations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">solve_args</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find an affine permutation A such that F A G^{-1} is affine.</span>

<span class="sd">    Given the left permutation F and the right permutation G^{-1},</span>
<span class="sd">    this method finds an affine permutation A such that F A G^{-1} is affine</span>
<span class="sd">    Note that this is equivalent to the existence of B such that B F A = G.</span>
<span class="sd">    In particular, if F = G, A is a right affine self-equivalence of F.</span>
<span class="sd">    If no solution is found, None is returned.</span>

<span class="sd">    If add_invertibility_equations is True, an additional constraint is added to ensure</span>
<span class="sd">    A is invertible (not needed if F and G are permutations with the same input size).</span>

<span class="sd">    This method does not support symbolic ANF, and the input functions F and G</span>
<span class="sd">    must be defined in the boolean polynomial ring</span>
<span class="sd">    BooleanPolynomialRing(n, &#39;x&#39;) with n the number of input variables.</span>

<span class="sd">    Named arguments from ``**solve_args`` are passed to solve_functional_equation().</span>
<span class="sd">    By default, return_mode=&quot;list_anfs&quot; and num_sat_solutions=&quot;1&quot;.</span>
<span class="sd">    If these two parameters are not given, only one solution is found</span>
<span class="sd">    and the ANF of A is returned.</span>

<span class="sd">        &gt;&gt;&gt; sage.all.set_random_seed(0)</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import lut2anf, invert_lut</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.equivalence import check_self_ae_anf</span>
<span class="sd">        &gt;&gt;&gt; anf = lut2anf((0, 1, 2, 3, 4, 6, 7, 5))</span>
<span class="sd">        &gt;&gt;&gt; inv_anf = lut2anf(invert_lut([x.__xor__(1) for x in [0, 1, 2, 3, 4, 6, 7, 5]]))</span>
<span class="sd">        &gt;&gt;&gt; right_se = find_half_affine_equivalence(anf, inv_anf)</span>
<span class="sd">        setting to 0 the free variables [a0_2, a0, a1_2, a1, a2]</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(right_se, input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [x0 x1 x2]</span>
<span class="sd">        [--------]</span>
<span class="sd">        [ 1  1  0]</span>
<span class="sd">        [ 1  0  0]</span>
<span class="sd">        [ 0  0  1]</span>
<span class="sd">        &gt;&gt;&gt; inv_anf = lut2anf(invert_lut((0, 1, 2, 3, 4, 6, 7, 5)))</span>
<span class="sd">        &gt;&gt;&gt; right_se = find_half_affine_equivalence(anf, inv_anf)</span>
<span class="sd">        setting to 0 the free variables [a0_2, a0, a1_2, a1, a2]</span>
<span class="sd">        &gt;&gt;&gt; assert check_self_ae_anf(anf, right_se, None, inv_anf)</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(right_se, input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [x0 x1 x2]</span>
<span class="sd">        [--------]</span>
<span class="sd">        [ 1  1  0]</span>
<span class="sd">        [ 1  0  0]</span>
<span class="sd">        [ 0  0  1]</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        The two lists with the inputs vars</span>
<span class="sd">        (containing Boolean variables or strings) of the given F and G</span>
<span class="sd">        (not needed for non-symbolic anfs)</span>
<span class="sd">        is not given since this method only supports non-symbolic ANF.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inv_right_anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>

    <span class="c1"># if solve_args.get(&quot;bpr&quot;, None) is not None:</span>
    <span class="c1">#     assert solve_args.get(&quot;ignore_initial_parsing&quot;, False) is not True</span>
    <span class="c1">#</span>
    <span class="c1"># if left_input_vars is None:</span>
    <span class="c1">#     aux_bpr = left_anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in left_anf)</span>
    <span class="c1">#     left_input_vars = aux_bpr.gens()</span>
    <span class="c1"># if inv_right_input_vars is None:</span>
    <span class="c1">#     aux_bpr = inv_right_anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in inv_right_anf)</span>
    <span class="c1">#     inv_right_input_vars = aux_bpr.gens()</span>

    <span class="n">left_input_vars</span> <span class="o">=</span> <span class="n">left_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
    <span class="n">inv_right_input_vars</span> <span class="o">=</span> <span class="n">inv_right_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>

    <span class="n">bpr_x</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_right_input_vars</span><span class="p">)),</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bpr&quot;</span><span class="p">,</span> <span class="n">bpr_x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">solve_args</span><span class="p">[</span><span class="s1">&#39;bpr&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">left_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inv_right_input_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">inv_right_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">left_input_vars</span> <span class="o">+</span> <span class="n">inv_right_input_vars</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_equiv_coeffs</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_equiv_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_anf</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_right_anf</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_right_input_vars</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_anf</span><span class="p">)</span>  <span class="c1"># n = num inputs = num outputs</span>

    <span class="n">f2</span> <span class="o">=</span> <span class="n">left_anf</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ct_terms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
                          <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_equiv_coeffs</span><span class="p">)</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="n">inv_right_anf</span>

    <span class="n">f1_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">lhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">]</span>
    <span class="n">lhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">inv_right_input_vars</span><span class="p">,</span> <span class="n">f1_input_vars</span><span class="p">,</span> <span class="n">left_input_vars</span><span class="p">]</span>

    <span class="n">rhs_degrees</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">rhs_input_vars</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">add_invertibility_equations</span><span class="p">:</span>
        <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="n">aux_iv</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f1_input_vars</span><span class="p">]</span>
        <span class="n">initial_equations</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">anf2matrix</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">aux_iv</span><span class="p">)</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span> <span class="o">+</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">initial_equations</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;num_sat_solutions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;list_anfs&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;initial_equations&quot;</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;initial_equations&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;initial_equations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_equations</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">solve_functional_equation</span><span class="p">(</span>
            <span class="n">lhs_anfs</span><span class="p">,</span> <span class="n">rhs_degrees</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="sa">f</span><span class="s2">&quot;No solution found (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span> <span class="ow">and</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_total_num_solutions&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="s2">&quot;ignoring return_total_num_solutions&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># return f1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="find_nondiagonal_ase"><a class="viewcode-back" href="../../boolcrypt.functionalequations.html#boolcrypt.functionalequations.find_nondiagonal_ase">[docs]</a><span class="k">def</span> <span class="nf">find_nondiagonal_ase</span><span class="p">(</span>
    <span class="n">left_anf</span><span class="p">,</span> <span class="n">right_anf</span><span class="p">,</span> <span class="n">se_ct_terms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># left_input_vars=None, right_input_vars=None,</span>
    <span class="n">prefix_se_left_coeffs</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">prefix_se_right_coeffs</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">solve_args</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find an affine non-diagonal self-equivalence of F || G.</span>

<span class="sd">    Given the function F by left_anf and G by right_anf,</span>
<span class="sd">    finds an affine self-equivalence (A, B) of the concatenation F || G,</span>
<span class="sd">    where A is non-diagonal (A in matrix form is not a block</span>
<span class="sd">    diagonal matrix up to block row permutations).</span>
<span class="sd">    If no solution is found, None is returned.</span>

<span class="sd">    If se_ct_terms=False, the constant terms of A and B are set to zero.</span>

<span class="sd">    This method does not support symbolic ANF, and the input functions F and G</span>
<span class="sd">    must be defined in the boolean polynomial ring</span>
<span class="sd">    BooleanPolynomialRing(n, &#39;x&#39;) with n the number of input variables.</span>

<span class="sd">    Named arguments from ``**solve_args`` are passed to solve_functional_equation().</span>
<span class="sd">    By default, return_mode=&quot;list_anfs&quot; and num_sat_solutions=&quot;1&quot;.</span>
<span class="sd">    If these two parameters are not given, only one solution is found</span>
<span class="sd">    and a pair with the ANF of A and B is returned.</span>

<span class="sd">        &gt;&gt;&gt; sage.all.set_random_seed(0)</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import lut2anf, invert_lut, get_lut_inversion</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.equivalence import check_self_le_anf</span>
<span class="sd">        &gt;&gt;&gt; left_anf = lut2anf([0, 1, 2, 3, 4, 5, 7, 6])</span>
<span class="sd">        &gt;&gt;&gt; right_anf = left_anf</span>
<span class="sd">        &gt;&gt;&gt; right_se, left_se = find_nondiagonal_ase(left_anf, right_anf, se_ct_terms=False)</span>
<span class="sd">        &gt;&gt;&gt; concat_anf = concatenate_anf(left_anf, right_anf)</span>
<span class="sd">        &gt;&gt;&gt; assert check_self_le_anf(concat_anf, right_se, left_se, None)</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(right_se, input_vars=[&quot;x&quot; + str(i) for i in range(6)])</span>
<span class="sd">        [x0 x1 x2 x3 x4 x5]</span>
<span class="sd">        [-----------------]</span>
<span class="sd">        [ 1  0  1  0  1  0]</span>
<span class="sd">        [ 0  1  0  0  0  0]</span>
<span class="sd">        [ 0  1  1  0  0  0]</span>
<span class="sd">        [ 0  0  0  1  0  0]</span>
<span class="sd">        [ 0  0  0  0  0  1]</span>
<span class="sd">        [ 0  0  0  0  1  0]</span>
<span class="sd">        &gt;&gt;&gt; left_anf = lut2anf(get_lut_inversion(3))</span>
<span class="sd">        &gt;&gt;&gt; right_anf = left_anf</span>
<span class="sd">        &gt;&gt;&gt; find_nondiagonal_ase(left_anf, right_anf, se_ct_terms=False)  # doctest:+SKIP</span>
<span class="sd">        No solution found (system of equations is inconsistent (unsatisfiable))</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        The two lists with the inputs vars</span>
<span class="sd">        (containing Boolean variables or strings) of the given F and G</span>
<span class="sd">        (not needed for non-symbolic anfs)</span>
<span class="sd">        is not given since this method only supports non-symbolic ANF.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>

    <span class="c1"># if solve_args.get(&quot;bpr&quot;, None) is not None:</span>
    <span class="c1">#     assert solve_args.get(&quot;ignore_initial_parsing&quot;, False) is not True</span>
    <span class="c1">#</span>
    <span class="c1"># if left_input_vars is None:</span>
    <span class="c1">#     aux_bpr = left_anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in left_anf)</span>
    <span class="c1">#     left_input_vars = aux_bpr.gens()</span>
    <span class="c1"># if right_input_vars is None:</span>
    <span class="c1">#     aux_bpr = right_anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in right_anf)</span>
    <span class="c1">#     right_input_vars = aux_bpr.gens()</span>

    <span class="n">left_input_vars</span> <span class="o">=</span> <span class="n">left_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
    <span class="n">right_input_vars</span> <span class="o">=</span> <span class="n">right_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>

    <span class="n">bpr_x</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">)),</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bpr&quot;</span><span class="p">,</span> <span class="n">bpr_x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">solve_args</span><span class="p">[</span><span class="s1">&#39;bpr&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">left_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">right_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_se_left_coeffs</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">left_input_vars</span> <span class="o">+</span> <span class="n">right_input_vars</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_se_right_coeffs</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">left_input_vars</span> <span class="o">+</span> <span class="n">right_input_vars</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_se_left_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_se_right_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>

    <span class="n">anf</span> <span class="o">=</span> <span class="n">concatenate_anf</span><span class="p">(</span><span class="n">left_anf</span><span class="p">,</span> <span class="n">right_anf</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
                          <span class="n">input_vars_left</span><span class="o">=</span><span class="n">left_input_vars</span><span class="p">,</span> <span class="n">input_vars_right</span><span class="o">=</span><span class="n">right_input_vars</span><span class="p">)</span>
    <span class="n">input_anf_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">))]</span>

    <span class="n">f0</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">se_ct_terms</span><span class="p">,</span>
                          <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_se_right_coeffs</span><span class="p">)</span>
    <span class="n">f0_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">))]</span>

    <span class="c1"># initial equations</span>
    <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">f0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="n">aux_iv</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f0_input_vars</span><span class="p">]</span>
    <span class="n">right_matrix</span> <span class="o">=</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">aux_iv</span><span class="p">)</span>
    <span class="n">right_matrix</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">):</span>
        <span class="n">left_block</span> <span class="o">=</span> <span class="n">right_matrix</span><span class="o">.</span><span class="n">subdivision</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
        <span class="n">right_block</span> <span class="o">=</span> <span class="n">right_matrix</span><span class="o">.</span><span class="n">subdivision</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">left_block</span> <span class="o">=</span> <span class="n">right_matrix</span><span class="o">.</span><span class="n">subdivision</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
        <span class="n">right_block</span> <span class="o">=</span> <span class="n">right_matrix</span><span class="o">.</span><span class="n">subdivision</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">or_bits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
    <span class="c1"># boolean_poly == 1 works, but 1 in boolean_poly.coefficients() not</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">left_block</span> <span class="ow">or</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">left_block</span><span class="p">:</span>
        <span class="n">eq1</span> <span class="o">=</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eq1</span> <span class="o">=</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">or_bits</span><span class="p">,</span> <span class="n">left_block</span><span class="p">))</span> <span class="o">+</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">right_block</span> <span class="ow">or</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">right_block</span><span class="p">:</span>
        <span class="n">eq2</span> <span class="o">=</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eq2</span> <span class="o">=</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">or_bits</span><span class="p">,</span> <span class="n">right_block</span><span class="p">))</span> <span class="o">+</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">initial_equations</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">find_equivalence</span><span class="p">(</span>
        <span class="n">anf</span><span class="p">,</span> <span class="n">anf</span><span class="p">,</span> <span class="n">left_equiv_degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">right_equiv_degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">equiv_ct_terms</span><span class="o">=</span><span class="n">se_ct_terms</span><span class="p">,</span>
        <span class="c1"># left_input_vars=input_anf_vars, right_input_vars=input_anf_vars,</span>
        <span class="n">prefix_left_equiv_coeffs</span><span class="o">=</span><span class="n">prefix_se_left_coeffs</span><span class="p">,</span>
        <span class="n">prefix_right_equiv_coeffs</span><span class="o">=</span><span class="n">prefix_se_right_coeffs</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
        <span class="n">initial_equations</span><span class="o">=</span><span class="n">initial_equations</span><span class="p">,</span> <span class="o">**</span><span class="n">solve_args</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="find_noninvertible_ase"><a class="viewcode-back" href="../../boolcrypt.functionalequations.html#boolcrypt.functionalequations.find_noninvertible_ase">[docs]</a><span class="k">def</span> <span class="nf">find_noninvertible_ase</span><span class="p">(</span>
    <span class="n">anf</span><span class="p">,</span> <span class="n">se_ct_terms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1"># input_anf_vars=None,</span>
    <span class="n">prefix_left_se_coeffs</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">prefix_right_se_coeffs</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">solve_args</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find a non-invertible pair (A, B) such that F A = B F.</span>

<span class="sd">    An affine non-invertible self-equivalence of F is a pair of</span>
<span class="sd">    non-invertible affine functions (A, B) such that B F = F A.</span>
<span class="sd">    A is also called a right SE and B a left SE.</span>
<span class="sd">    If no solution is found, None is returned.</span>

<span class="sd">    If se_ct_terms=False, the constant terms of A and B are set to zero.</span>

<span class="sd">    This method does not support symbolic ANF, and the input function F</span>
<span class="sd">    must be defined in the boolean polynomial ring</span>
<span class="sd">    BooleanPolynomialRing(n,&#39;x&#39;) with n the number of input variables.</span>

<span class="sd">    Named arguments from ``**solve_args`` are passed to solve_functional_equation().</span>
<span class="sd">    By default, return_mode=&quot;list_anfs&quot; and num_sat_solutions=&quot;1&quot;.</span>
<span class="sd">    If these two parameters are not given, only one solution is found</span>
<span class="sd">    and a pair containing the ANF of A and B is returned.</span>

<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import lut2anf, get_lut_inversion</span>
<span class="sd">        &gt;&gt;&gt; anf = lut2anf([0, 1, 2, 3, 4, 5, 7, 6])</span>
<span class="sd">        &gt;&gt;&gt; right_se, left_se = find_noninvertible_ase(anf)</span>
<span class="sd">        setting to 0 the free variables [b0, b1, b2]</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(right_se, input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [x1]</span>
<span class="sd">        [--]</span>
<span class="sd">        [ 0]</span>
<span class="sd">        [ 0]</span>
<span class="sd">        [ 1]</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(left_se, input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;])</span>
<span class="sd">        [x1]</span>
<span class="sd">        [--]</span>
<span class="sd">        [ 0]</span>
<span class="sd">        [ 0]</span>
<span class="sd">        [ 1]</span>
<span class="sd">        &gt;&gt;&gt; find_noninvertible_ase(lut2anf(get_lut_inversion(3)))</span>
<span class="sd">        No solution found (system of equations is inconsistent (unsatisfiable))</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        The list of the inputs vars (containing Boolean variables</span>
<span class="sd">        or strings) of the given anf (not needed for non-symbolic anf)</span>
<span class="sd">        is not given since this method only supports non-symbolic ANF.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>

    <span class="c1"># if solve_args.get(&quot;bpr&quot;, None) is not None:</span>
    <span class="c1">#     assert solve_args.get(&quot;ignore_initial_parsing&quot;, False) is not True</span>
    <span class="c1">#</span>
    <span class="c1"># if input_anf_vars is None:</span>
    <span class="c1">#     aux_bpr = anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in anf)</span>
    <span class="c1">#     input_anf_vars = aux_bpr.gens()</span>

    <span class="n">input_anf_vars</span> <span class="o">=</span> <span class="n">anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>

    <span class="n">bpr_x</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">),</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bpr&quot;</span><span class="p">,</span> <span class="n">bpr_x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">solve_args</span><span class="p">[</span><span class="s1">&#39;bpr&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_right_se_coeffs</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">input_anf_vars</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_left_se_coeffs</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">input_anf_vars</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_right_se_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_left_se_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>

    <span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_outputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)</span>

    <span class="n">f1</span> <span class="o">=</span> <span class="n">anf</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_inputs</span><span class="p">,</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">se_ct_terms</span><span class="p">,</span>
                          <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_right_se_coeffs</span><span class="p">)</span>
    <span class="n">g1</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">,</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">se_ct_terms</span><span class="p">,</span>
                          <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_left_se_coeffs</span><span class="p">)</span>
    <span class="n">g0</span> <span class="o">=</span> <span class="n">anf</span>
    <span class="n">f1_input_vars</span><span class="p">,</span> <span class="n">g0_input_vars</span> <span class="o">=</span> <span class="n">input_anf_vars</span><span class="p">,</span> <span class="n">input_anf_vars</span>
    <span class="n">f0_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_inputs</span><span class="p">)]</span>
    <span class="n">g1_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_outputs</span><span class="p">)]</span>

    <span class="n">lhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">]</span>
    <span class="n">lhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0_input_vars</span><span class="p">,</span> <span class="n">f1_input_vars</span><span class="p">]</span>
    <span class="n">rhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0</span><span class="p">,</span> <span class="n">g1</span><span class="p">]</span>
    <span class="n">rhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0_input_vars</span><span class="p">,</span> <span class="n">g1_input_vars</span><span class="p">]</span>

    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;num_sat_solutions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;list_anfs&quot;</span>

    <span class="c1"># initial equations</span>
    <span class="n">aux_bpr</span> <span class="o">=</span> <span class="n">f0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="n">aux_iv</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_bpr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">f0_input_vars</span><span class="p">]</span>
    <span class="n">right_matrix</span> <span class="o">=</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">aux_iv</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">or_bits</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">right_matrix</span><span class="o">.</span><span class="n">list</span><span class="p">()</span> <span class="ow">or</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">right_matrix</span><span class="o">.</span><span class="n">list</span><span class="p">():</span>
        <span class="n">eq1</span> <span class="o">=</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eq1</span> <span class="o">=</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="n">sage</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">or_bits</span><span class="p">,</span> <span class="n">right_matrix</span><span class="o">.</span><span class="n">list</span><span class="p">()))</span> <span class="o">+</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">eq2</span> <span class="o">=</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="n">right_matrix</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span> <span class="o">+</span> <span class="n">aux_bpr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">initial_equations</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">solve_functional_equation</span><span class="p">(</span>
            <span class="n">lhs_anfs</span><span class="p">,</span> <span class="n">rhs_anfs</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">,</span>
            <span class="n">initial_equations</span><span class="o">=</span><span class="n">initial_equations</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="sa">f</span><span class="s2">&quot;No solution found (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span> <span class="ow">and</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_total_num_solutions&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="s2">&quot;ignoring return_total_num_solutions&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># return f0 and g1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="find_horizontal_decomposition"><a class="viewcode-back" href="../../boolcrypt.functionalequations.html#boolcrypt.functionalequations.find_horizontal_decomposition">[docs]</a><span class="k">def</span> <span class="nf">find_horizontal_decomposition</span><span class="p">(</span>
    <span class="n">anf</span><span class="p">,</span> <span class="n">degree_anf</span><span class="p">,</span> <span class="n">num_inputs_first_factor</span><span class="p">,</span> <span class="n">aff_ct_terms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># input_anf_vars=None,</span>
    <span class="n">prefix_left_aff_coeffs</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">prefix_right_aff_coeffs</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
    <span class="n">prefix_first_factor</span><span class="o">=</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">prefix_second_factor</span><span class="o">=</span><span class="s2">&quot;q&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">solve_args</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find an horizontal decomposition P(x&#39;)|Q(x&#39;&#39;) of G(x) in the affine class.</span>

<span class="sd">    An horizontal decomposition of G(x) is a pair of functions P(x&#39;), Q(x&#39;&#39;),</span>
<span class="sd">    such that x = x&#39; || x&#39;&#39; and (P,Q) and G are affine equivalent</span>
<span class="sd">    (linear equivalent if aff_ct_terms=False), that is, B (P, Q) A = G.</span>
<span class="sd">    P and Q are called the first and the second factor, respectively.</span>
<span class="sd">    If no solution is found, None is returned.</span>

<span class="sd">    The triple ((P, Q), A, B) is found by solving B (P, Q) A = G.</span>

<span class="sd">    If aff_ct_terms=False, finds A and B linear instead of affine.</span>

<span class="sd">    This method does not support symbolic ANF, and the input function G</span>
<span class="sd">    must be defined in the boolean polynomial ring</span>
<span class="sd">    BooleanPolynomialRing(n,&#39;x&#39;) with n the number of input variables.</span>

<span class="sd">    Named arguments from ``**solve_args`` are passed to solve_functional_equation().</span>
<span class="sd">    By default, return_mode=&quot;list_anfs&quot; and num_sat_solutions=&quot;1&quot;.</span>
<span class="sd">    If these two parameters are not given, only one solution is found</span>
<span class="sd">    abd the triple ((P, Q), A, B), each one in ANF form, is returned.</span>

<span class="sd">        &gt;&gt;&gt; sage.all.set_random_seed(0)</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import lut2anf, get_lut_inversion</span>
<span class="sd">        &gt;&gt;&gt; anf = lut2anf([1, 0, 3, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])  # 2nd to last 4b aff class</span>
<span class="sd">        &gt;&gt;&gt; decomp, right_aff, left_aff = find_horizontal_decomposition(anf, 2, 1)</span>
<span class="sd">        setting to 0 the free variables [a0, p0, q0, q1, q2]</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(decomp, input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;])</span>
<span class="sd">        [x2*x3|   x0    x1    x2    x3]</span>
<span class="sd">        [-----+-----------------------]</span>
<span class="sd">        [    0|    1     0     0     0]</span>
<span class="sd">        [    0|    0     0     1     0]</span>
<span class="sd">        [    0|    0     0     0     1]</span>
<span class="sd">        [    1|    0     1     1     1]</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(right_aff, input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;])</span>
<span class="sd">        [x0 x1 x2 x3]</span>
<span class="sd">        [-----------]</span>
<span class="sd">        [ 0  1  0  0]</span>
<span class="sd">        [ 1  0  0  0]</span>
<span class="sd">        [ 0  0  1  0]</span>
<span class="sd">        [ 0  0  0  1]</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(left_aff, input_vars=[&quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;])</span>
<span class="sd">        [x0 x1 x2 x3| 1]</span>
<span class="sd">        [-----------+--]</span>
<span class="sd">        [ 0  0  0  1| 1]</span>
<span class="sd">        [ 1  0  0  0| 0]</span>
<span class="sd">        [ 0  1  0  0| 0]</span>
<span class="sd">        [ 0  0  1  0| 0]</span>
<span class="sd">        &gt;&gt;&gt; anf = lut2anf((0, 1, 2, 3, 4, 6, 7, 5))</span>
<span class="sd">        &gt;&gt;&gt; find_horizontal_decomposition(anf, 2, 1)  # non-linear 3b cannot be decomposed</span>
<span class="sd">        No solution found (system of equations is inconsistent (unsatisfiable))</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        The list of the inputs vars (containing Boolean variables</span>
<span class="sd">        or strings) of the given anf G (not needed for non-symbolic anfs).</span>
<span class="sd">        is not given since this method only supports non-symbolic ANF.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>

    <span class="c1"># if solve_args.get(&quot;bpr&quot;, None) is not None:</span>
    <span class="c1">#     assert solve_args.get(&quot;ignore_initial_parsing&quot;, False) is not True</span>
    <span class="c1">#</span>
    <span class="c1"># if input_anf_vars is None:</span>
    <span class="c1">#     aux_bpr = anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in anf)</span>
    <span class="c1">#     input_anf_vars = aux_bpr.gens()</span>

    <span class="n">input_anf_vars</span> <span class="o">=</span> <span class="n">anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>

    <span class="n">bpr_x</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">),</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bpr&quot;</span><span class="p">,</span> <span class="n">bpr_x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">solve_args</span><span class="p">[</span><span class="s1">&#39;bpr&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="n">num_p_vars</span> <span class="o">=</span> <span class="n">num_inputs_first_factor</span>

    <span class="n">concat_anf</span> <span class="o">=</span> <span class="n">concatenate_anf</span><span class="p">(</span>
        <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">degree_anf</span><span class="p">,</span> <span class="n">num_p_vars</span><span class="p">,</span> <span class="n">num_p_vars</span><span class="p">,</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">aff_ct_terms</span><span class="p">,</span>
                         <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_first_factor</span><span class="p">),</span>
        <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">degree_anf</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_p_vars</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">anf</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_p_vars</span><span class="p">,</span>
                         <span class="n">ct_terms</span><span class="o">=</span><span class="n">aff_ct_terms</span><span class="p">,</span>
                         <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_second_factor</span><span class="p">),</span>
        <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">input_vars_left</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_p_vars</span><span class="p">)],</span>
        <span class="n">input_vars_right</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_p_vars</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="n">input_concat_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_anf_vars</span><span class="p">))]</span>

    <span class="c1"># simplify_output = &quot;return_mode&quot; not in solve_args and &quot;num_sat_solutions&quot; not in solve_args</span>
    <span class="c1"># if &quot;return_mode&quot; not in solve_args:</span>
    <span class="c1">#     # force full output in result</span>
    <span class="c1">#     solve_args[&quot;return_mode&quot;] = &quot;list_anfs&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># result = find_equivalence(</span>
    <span class="c1">#     concat_anf, anf, left_equiv_degree=1, right_equiv_degree=1, equiv_ct_terms=aff_ct_terms,</span>
    <span class="c1">#     # left_input_vars=input_concat_vars, right_input_vars=input_anf_vars,</span>
    <span class="c1">#     prefix_left_equiv_coeffs=prefix_left_aff_coeffs,</span>
    <span class="c1">#     prefix_right_equiv_coeffs=prefix_right_aff_coeffs,</span>
    <span class="c1">#     verbose=verbose, debug=debug, filename=filename, **solve_args</span>
    <span class="c1"># )</span>
    <span class="c1">#</span>
    <span class="c1"># if result and simplify_output:</span>
    <span class="c1">#     if solve_args.get(&quot;return_total_num_solutions&quot;, False):</span>
    <span class="c1">#         get_smart_print(filename)(&quot;ignoring return_total_num_solutions&quot;)</span>
    <span class="c1">#     return result[0][0][1], result[0][0][0], result[0][0][2]  # return f1, f0, f2</span>
    <span class="c1"># else:</span>
    <span class="c1">#     return result</span>

    <span class="c1"># duplicated code from find_equivalence since find_equivalence</span>
    <span class="c1"># does not support symbolic ANF (like concat_anf)</span>
    <span class="n">left_anf</span> <span class="o">=</span> <span class="n">concat_anf</span>
    <span class="n">right_anf</span> <span class="o">=</span> <span class="n">anf</span>
    <span class="n">left_equiv_degree</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">right_equiv_degree</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">left_input_vars</span> <span class="o">=</span> <span class="n">input_concat_vars</span>
    <span class="n">right_input_vars</span> <span class="o">=</span> <span class="n">input_anf_vars</span>
    <span class="n">equiv_ct_terms</span> <span class="o">=</span> <span class="n">aff_ct_terms</span>
    <span class="n">prefix_left_equiv_coeffs</span> <span class="o">=</span> <span class="n">prefix_left_aff_coeffs</span>
    <span class="n">prefix_right_equiv_coeffs</span> <span class="o">=</span> <span class="n">prefix_right_aff_coeffs</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">,</span> <span class="n">right_input_vars</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_left_equiv_coeffs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_right_equiv_coeffs</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_left_equiv_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_right_equiv_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>

    <span class="n">f2</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">left_equiv_degree</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_anf</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_anf</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">equiv_ct_terms</span><span class="p">,</span>
                          <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_left_equiv_coeffs</span><span class="p">)</span>
                          <span class="c1"># bpr=bpr, coeff2expr=initial_fixed_vars)</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">left_anf</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">right_equiv_degree</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">equiv_ct_terms</span><span class="p">,</span>
                          <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_right_equiv_coeffs</span><span class="p">)</span>
                          <span class="c1"># bpr=bpr, coeff2expr=initial_fixed_vars)</span>
    <span class="n">f2_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_anf</span><span class="p">))]</span>
    <span class="n">f1_input_vars</span> <span class="o">=</span> <span class="n">left_input_vars</span>
    <span class="n">f0_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">))]</span>

    <span class="c1"># if bpr is not None:</span>
    <span class="c1">#     f2_input_vars = [bpr(v) for v in f2_input_vars]</span>
    <span class="c1">#     f0_input_vars = [bpr(v) for v in f0_input_vars]</span>

    <span class="n">g0</span> <span class="o">=</span> <span class="n">right_anf</span>
    <span class="n">g0_input_vars</span> <span class="o">=</span> <span class="n">right_input_vars</span>

    <span class="n">lhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">]</span>
    <span class="n">lhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0_input_vars</span><span class="p">,</span> <span class="n">f1_input_vars</span><span class="p">,</span> <span class="n">f2_input_vars</span><span class="p">]</span>

    <span class="n">rhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0</span><span class="p">]</span>
    <span class="n">rhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0_input_vars</span><span class="p">]</span>

    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;num_sat_solutions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;list_anfs&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">solve_functional_equation</span><span class="p">(</span>
            <span class="n">lhs_anfs</span><span class="p">,</span> <span class="n">rhs_anfs</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="sa">f</span><span class="s2">&quot;No solution found (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span> <span class="ow">and</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_total_num_solutions&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="s2">&quot;ignoring return_total_num_solutions&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># return f1, f0, f2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="find_ccz_equivalence"><a class="viewcode-back" href="../../boolcrypt.functionalequations.html#boolcrypt.functionalequations.find_ccz_equivalence">[docs]</a><span class="k">def</span> <span class="nf">find_ccz_equivalence</span><span class="p">(</span>
    <span class="n">left_anf</span><span class="p">,</span> <span class="n">right_anf</span><span class="p">,</span>
    <span class="n">equiv_degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># inv_equiv_degree=1,</span>
    <span class="n">equiv_ct_terms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">add_invertibility_equations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># left_input_vars=None, right_input_vars=None,</span>
    <span class="n">prefix_am_coeffs</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">solve_args</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find an affine A such that A(graph F) = graph G.</span>

<span class="sd">    Given the left function F and the right function G,</span>
<span class="sd">    this method finds an invertible admissible mapping A of given degree</span>
<span class="sd">    such that the graph of G is equal to the graph of F transformed by A.</span>
<span class="sd">    If no solution is found, None is returned.</span>

<span class="sd">    Graph(f) is is the set of points {(x, F(x))}, and similar for Graph(G).</span>

<span class="sd">    If the given degree is 1 and equiv_ct_terms=True (resp. False),</span>
<span class="sd">    this method finds an affine (resp. linear) admissible mapping.</span>

<span class="sd">    If F and G are the same, this methods finds</span>
<span class="sd">    Graph(F) self-equivalences/automorphisms, that is,</span>
<span class="sd">    invertibles A such that A(graph F) = graph F.</span>

<span class="sd">    A = (a_0, a_1) is returned by solving the functional equation</span>
<span class="sd">    G(a_0(u, F(u))) = a_1(u, F(u)).</span>

<span class="sd">    If add_invertibility_equations=True, the equations that</span>
<span class="sd">    impose A to be invertible are added to the system of equations</span>
<span class="sd">    (only supported for equiv_degree=1).</span>

<span class="sd">    This method does not support symbolic ANF, and the input functions F and G</span>
<span class="sd">    must be defined in the boolean polynomial ring</span>
<span class="sd">    BooleanPolynomialRing(n, &#39;x&#39;) with n the number of input variables.</span>

<span class="sd">    Named arguments from ``**solve_args`` are passed to solve_functional_equation().</span>
<span class="sd">    By default, return_mode=&quot;list_anfs&quot; and num_sat_solutions=&quot;1&quot;.</span>
<span class="sd">    If these two parameters are not given, only one solution is found</span>
<span class="sd">    and the ANF of A is returned.</span>

<span class="sd">        &gt;&gt;&gt; sage.all.set_random_seed(0)</span>
<span class="sd">        &gt;&gt;&gt; from boolcrypt.utilities import get_lut_inversion, lut2anf</span>
<span class="sd">        &gt;&gt;&gt; left_anf = lut2anf((0, 1, 2, 3, 4, 6, 7, 5))</span>
<span class="sd">        &gt;&gt;&gt; am = find_ccz_equivalence(left_anf, left_anf, only_linear_fixed_vars=True, equiv_ct_terms=False)</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(am, input_vars=[&quot;x&quot; + str(i) for i in range(3*2)])  # Graph-SE</span>
<span class="sd">        [x0 x1 x2 x3 x4 x5]</span>
<span class="sd">        [-----------------]</span>
<span class="sd">        [ 0  0  0  0  1  0]</span>
<span class="sd">        [ 1  0  0  0  0  0]</span>
<span class="sd">        [ 0  0  0  0  0  1]</span>
<span class="sd">        [ 1  1  0  1  0  0]</span>
<span class="sd">        [ 0  0  1  1  0  1]</span>
<span class="sd">        [ 0  0  1  0  0  0]</span>
<span class="sd">        &gt;&gt;&gt; find_ccz_equivalence(left_anf, lut2anf(get_lut_inversion(3)), only_linear_fixed_vars=True)  # doctest:+SKIP</span>
<span class="sd">        No solution found (system of equations is inconsistent (unsatisfiable))</span>
<span class="sd">        &gt;&gt;&gt; # CCZ of inversion found with sboxU.ccz_equivalent_permutations</span>
<span class="sd">        &gt;&gt;&gt; left_anf = lut2anf([0, 15, 9, 7, 4, 14, 1, 3, 10, 6, 13, 2, 8, 5, 11, 12])</span>
<span class="sd">        &gt;&gt;&gt; right_anf = lut2anf(get_lut_inversion(4))</span>
<span class="sd">        &gt;&gt;&gt; # next call might require to increase Python&#39;s recursionlimit</span>
<span class="sd">        &gt;&gt;&gt; am = find_ccz_equivalence(left_anf, right_anf, equiv_ct_terms=False,</span>
<span class="sd">        ...     only_linear_fixed_vars=True, verbose=True)  # doctest:+SKIP</span>
<span class="sd">        &gt;&gt;&gt; get_anf_coeffmatrix_str(am, input_vars=[&quot;x&quot; + str(i) for i in range(4*2)])  # doctest:+SKIP</span>
<span class="sd">        [x0 x1 x2 x3 x4 x5 x6 x7]</span>
<span class="sd">        [-----------------------]</span>
<span class="sd">        [ 0  1  0  1  0  0  0  0]</span>
<span class="sd">        [ 0  0  1  1  0  0  0  0]</span>
<span class="sd">        [ 1  1  1  1  0  0  0  0]</span>
<span class="sd">        [ 1  1  0  1  0  0  0  0]</span>
<span class="sd">        [ 0  1  1  1  1  1  0  0]</span>
<span class="sd">        [ 0  1  0  1  1  1  1  0]</span>
<span class="sd">        [ 0  0  0  0  1  0  1  0]</span>
<span class="sd">        [ 0  0  1  0  1  0  1  1]</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        The two lists with the inputs vars</span>
<span class="sd">        (containing Boolean variables or strings) of the given F and G</span>
<span class="sd">        (not needed for non-symbolic anfs)</span>
<span class="sd">        is not given since this method only supports non-symbolic ANF.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The original equation is with the inverse, that is,</span>
    <span class="c1"># if B^{-1} = (b_0, b_1) verifies b_1(u, F(u)) = G(b_0(u, F(u))),</span>
    <span class="c1"># then Gamma_F = B(Gamma_G).</span>
    <span class="c1"># But this is equivalent to B(Gamma_F) = Gamma_G</span>

    <span class="c1"># if equiv_degree == 1 or inv_equiv_degree == 1:</span>
    <span class="c1">#     assert equiv_degree == inv_equiv_degree == 1</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_anf</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">pbori</span><span class="o">.</span><span class="n">BooleanPolynomial</span><span class="p">)</span>

    <span class="c1"># if solve_args.get(&quot;bpr&quot;, None) is not None:</span>
    <span class="c1">#     assert solve_args.get(&quot;ignore_initial_parsing&quot;, False) is not True</span>
    <span class="c1">#</span>
    <span class="c1"># if left_input_vars is None:</span>
    <span class="c1">#     aux_bpr = left_anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in left_anf)</span>
    <span class="c1">#     left_input_vars = aux_bpr.gens()</span>
    <span class="c1"># if right_input_vars is None:</span>
    <span class="c1">#     aux_bpr = right_anf[0].parent()</span>
    <span class="c1">#     assert all(aux_bpr == f.parent() for f in right_anf)</span>
    <span class="c1">#     right_input_vars = aux_bpr.gens()</span>

    <span class="n">left_input_vars</span> <span class="o">=</span> <span class="n">left_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
    <span class="n">right_input_vars</span> <span class="o">=</span> <span class="n">right_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>

    <span class="n">bpr_x</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">)),</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bpr&quot;</span><span class="p">,</span> <span class="n">bpr_x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">solve_args</span><span class="p">[</span><span class="s1">&#39;bpr&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">left_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">bpr_x</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;only the boolean polynomial ring </span><span class="si">{</span><span class="n">bpr_x</span><span class="si">}</span><span class="s2"> is supported &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;(and not </span><span class="si">{</span><span class="n">right_anf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix_am_coeffs</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">left_input_vars</span> <span class="o">+</span> <span class="n">right_input_vars</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">prefix_am_coeffs</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_anf</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_anf</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_input_vars</span><span class="p">)</span>

    <span class="n">num_a_inputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_anf</span><span class="p">)</span>

    <span class="n">a_0</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">equiv_degree</span><span class="p">,</span> <span class="n">num_a_inputs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">equiv_ct_terms</span><span class="p">,</span>
                           <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_am_coeffs</span><span class="o">+</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
    <span class="n">a_1</span> <span class="o">=</span> <span class="n">get_symbolic_anf</span><span class="p">(</span><span class="n">equiv_degree</span><span class="p">,</span> <span class="n">num_a_inputs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_anf</span><span class="p">),</span> <span class="n">ct_terms</span><span class="o">=</span><span class="n">equiv_ct_terms</span><span class="p">,</span>
                           <span class="n">prefix_inputs</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">prefix_coeffs</span><span class="o">=</span><span class="n">prefix_am_coeffs</span><span class="o">+</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
    <span class="n">a_varnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">variable_names</span><span class="p">())</span>
    <span class="n">a_varnames</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vn</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">a_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">variable_names</span><span class="p">()</span> <span class="k">if</span> <span class="n">vn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_varnames</span><span class="p">)</span>
    <span class="n">a_bpr</span> <span class="o">=</span> <span class="n">BooleanPolynomialRing</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_varnames</span><span class="p">),</span> <span class="n">a_varnames</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">a_0</span><span class="p">,</span> <span class="n">a_1</span><span class="p">):</span>
        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_bpr</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>

    <span class="c1"># G(a_0(u, F(u))) = a_1(u, F(u))</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">right_anf</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">a_0</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">,</span> <span class="n">left_anf</span><span class="p">):</span>
        <span class="n">f0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>

    <span class="n">f2_input_vars</span> <span class="o">=</span> <span class="n">right_input_vars</span>
    <span class="n">f1_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_a_inputs</span><span class="p">)]</span>
    <span class="n">f0_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left_input_vars</span><span class="p">))]</span>

    <span class="n">g1</span> <span class="o">=</span> <span class="n">a_1</span>
    <span class="n">g0</span> <span class="o">=</span> <span class="n">f0</span>

    <span class="n">g1_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_a_inputs</span><span class="p">)]</span>
    <span class="n">g0_input_vars</span> <span class="o">=</span> <span class="n">f0_input_vars</span>

    <span class="n">lhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">]</span>
    <span class="n">lhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">f0_input_vars</span><span class="p">,</span> <span class="n">f1_input_vars</span><span class="p">,</span> <span class="n">f2_input_vars</span><span class="p">]</span>

    <span class="n">rhs_anfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0</span><span class="p">,</span> <span class="n">g1</span><span class="p">]</span>
    <span class="n">rhs_input_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">g0_input_vars</span><span class="p">,</span> <span class="n">g1_input_vars</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">add_invertibility_equations</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">equiv_degree</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">a_matrix</span> <span class="o">=</span> <span class="n">anf2matrix</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="n">a_bpr</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_a_inputs</span><span class="p">)])</span>
        <span class="n">initial_equations</span> <span class="o">=</span> <span class="p">[</span><span class="n">a_bpr</span><span class="p">(</span><span class="n">a_matrix</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span> <span class="o">+</span> <span class="n">a_bpr</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
        <span class="c1"># # not fully tested</span>
        <span class="c1"># initial_equations = find_inverse(</span>
        <span class="c1">#     a, inv_equiv_degree, inv_position=&quot;left&quot;, prefix_inv_coeffs=prefix_am_coeffs+&quot;c&quot;,</span>
        <span class="c1">#     input_vars=[&quot;x&quot; + str(i) for i in range(num_a_inputs)],</span>
        <span class="c1">#     verbose=verbose, debug=debug, filename=filename, return_mode=&quot;raw_equations&quot;</span>
        <span class="c1"># )</span>
        <span class="c1"># assert initial_equations is not None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">initial_equations</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">new_kwargs</span> <span class="o">=</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;num_sat_solutions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;return_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;list_anfs&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;initial_equations&quot;</span> <span class="ow">in</span> <span class="n">new_kwargs</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;initial_equations&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">initial_equations</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_kwargs</span><span class="p">[</span><span class="s2">&quot;initial_equations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_equations</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">solve_functional_equation</span><span class="p">(</span>
            <span class="n">lhs_anfs</span><span class="p">,</span> <span class="n">rhs_anfs</span><span class="p">,</span> <span class="n">lhs_input_vars</span><span class="p">,</span> <span class="n">rhs_input_vars</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="sa">f</span><span class="s2">&quot;No solution found (</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;return_mode&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span> <span class="ow">and</span> <span class="s2">&quot;num_sat_solutions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solve_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">solve_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_total_num_solutions&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)(</span><span class="s2">&quot;ignoring return_total_num_solutions&quot;</span><span class="p">)</span>
            <span class="n">a_0_sol</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># f1</span>
            <span class="n">a_1_sol</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># g1</span>
            <span class="n">a_sol</span> <span class="o">=</span> <span class="n">BooleanPolynomialVector</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">a_0_sol</span><span class="p">,</span> <span class="n">a_1_sol</span><span class="p">):</span>
                <span class="n">a_sol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">a_sol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Adrin Ranea.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>